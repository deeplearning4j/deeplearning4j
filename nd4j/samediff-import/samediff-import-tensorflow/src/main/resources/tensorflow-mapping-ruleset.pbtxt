mappings {
  frameworkName: "tensorflow"
  opName: "unique"
  inputFrameworkOpName: "UniqueV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "UniqueV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "conv2d"
  inputFrameworkOpName: "Conv2D"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "filter"
    outputTensorName: "input"
    outputTensorName: "weights"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "weights"
      value: "filter"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "wFormat"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "wFormat"
        argType: INT64
        argIndex: 10
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "stringnotequalsadapterrule"
    functionName: "stringnotequalsadapterrule"
    inputStringAttrName: "data_format"
    outputIntName: "isNCHW"
    inputFloatName: "data_format"
    inputToOutput {
      key: "isNCHW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNCHW"
      transformerArgs {
        name: "data_format"
        argIndex: 9
        stringValue: "NCHW"
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputIntName: "isSameMode"
    inputToOutput {
      key: "isSameMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isSameMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        argIndex: 8
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "sH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "sW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "dH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "dH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "dW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "dW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "kH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "kH"
        int64Value: -1
        argType: INT64
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "kW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "kW"
        int64Value: -1
        argType: INT64
        argIndex: 1
      }
    }
    inputFrameworkOpName: "Conv2D"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "random_poisson"
  inputFrameworkOpName: "RandomPoisson"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "shape"
    inputTensorName: "rate"
    outputTensorName: "shape"
    outputTensorName: "lambda"
    inputToOutput {
      key: "shape"
      value: "shape"
    }
    inputToOutput {
      key: "lambda"
      value: "rate"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RandomPoisson"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "seed"
    outputIntName: "seed"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "seed"
      value: "seed"
    }
    inputToOutput {
      key: "dtype"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomPoisson"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "maxpool2d"
  inputFrameworkOpName: "MaxPool"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dW"
        int64Value: 1
        argType: INT64
        argIndex: 6
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dH"
        int64Value: 1
        argType: INT64
        argIndex: 7
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "extraParam0"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "extraParam0"
        int64Value: 1
        argType: INT64
        argIndex: 9
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "stringnotequalsadapterrule"
    functionName: "stringnotequalsadapterrule"
    inputStringAttrName: "data_format"
    outputIntName: "isNCHW"
    inputFloatName: "data_format"
    inputToOutput {
      key: "isNCHW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNCHW"
      transformerArgs {
        name: "data_format"
        argIndex: 10
        stringValue: "NCHW"
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputIntName: "isSameMode"
    inputToOutput {
      key: "isSameMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isSameMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        argIndex: 8
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "sH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "sW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "kH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "kH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "kW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "kW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    inputFrameworkOpName: "MaxPool"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "size"
  inputFrameworkOpName: "Size"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Size"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "squaredsubtract"
  inputFrameworkOpName: "SquaredDifference"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SquaredDifference"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "SquaredDifference"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "SquaredDifference"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "randomuniform"
  inputFrameworkOpName: "StatelessRandomUniform"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "shape"
    outputTensorName: "shape"
    inputToOutput {
      key: "shape"
      value: "shape"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "StatelessRandomUniform"
  }
  rule {
    ruleName: "datatypetoint"
    functionName: "datatypetoint"
    outputIntName: "dtype"
    inputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "StatelessRandomUniform"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "StatelessRandomUniform"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "min"
    inputFloatName: "max"
    inputTensorName: "min"
    inputTensorName: "max"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "min"
        argType: DOUBLE
      }
      transformerArgs {
        name: "max"
        doubleValue: 1.0
        argType: DOUBLE
        argIndex: 1
      }
      transformerArgs {
        name: "min"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 1
      }
      transformerArgs {
        name: "max"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 2
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "min"
        argType: DOUBLE
      }
      transformerArgs {
        name: "max"
        doubleValue: 1.0
        argType: DOUBLE
        argIndex: 1
      }
      transformerArgs {
        name: "min"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 1
      }
      transformerArgs {
        name: "max"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 2
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "min"
        argType: DOUBLE
      }
      transformerArgs {
        name: "max"
        doubleValue: 1.0
        argType: DOUBLE
        argIndex: 1
      }
      transformerArgs {
        name: "min"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 1
      }
      transformerArgs {
        name: "max"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 2
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "min"
        argType: DOUBLE
      }
      transformerArgs {
        name: "max"
        doubleValue: 1.0
        argType: DOUBLE
        argIndex: 1
      }
      transformerArgs {
        name: "min"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 1
      }
      transformerArgs {
        name: "max"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 2
      }
    }
    inputFrameworkOpName: "StatelessRandomUniform"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "shift_bits"
  inputFrameworkOpName: "LeftShift"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LeftShift"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "LeftShift"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "isinf"
  inputFrameworkOpName: "IsInf"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "IsInf"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "IsInf"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "digamma"
  inputFrameworkOpName: "Digamma"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Digamma"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "random_shuffle"
  inputFrameworkOpName: "RandomShuffle"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "value"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "value"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RandomShuffle"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "seed"
    outputIntName: "seeds"
    inputToOutput {
      key: "seeds"
      value: "seed"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomShuffle"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "adjust_hue"
  inputFrameworkOpName: "AdjustHue"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    inputTensorName: "delta"
    outputTensorName: "input"
    outputTensorName: "delta"
    inputToOutput {
      key: "input"
      value: "images"
    }
    inputToOutput {
      key: "delta"
      value: "delta"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "AdjustHue"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dimC"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dimC"
        int64Value: -1
        argType: INT64
      }
    }
    inputFrameworkOpName: "AdjustHue"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "Assert"
  inputFrameworkOpName: "Assert"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "condition"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "condition"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Assert"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matrix_determinant"
  inputFrameworkOpName: "MatrixDeterminant"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MatrixDeterminant"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "MatrixDeterminant"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "adjust_saturation"
  inputFrameworkOpName: "AdjustSaturation"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    inputTensorName: "scale"
    outputTensorName: "input"
    outputTensorName: "factor"
    inputToOutput {
      key: "input"
      value: "images"
    }
    inputToOutput {
      key: "factor"
      value: "scale"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "AdjustSaturation"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dimC"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dimC"
        int64Value: -1
        argType: INT64
      }
    }
    inputFrameworkOpName: "AdjustSaturation"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "ones_as"
  inputFrameworkOpName: "OnesLike"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "OnesLike"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    outputIntName: "dataType"
    inputDataTypeName: "T"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "OnesLike"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_min"
  inputFrameworkOpName: "TensorScatterMin"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "tensor"
    inputTensorName: "indices"
    inputTensorName: "updates"
    outputTensorName: "input"
    outputTensorName: "indices"
    outputTensorName: "updates"
    inputToOutput {
      key: "input"
      value: "tensor"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorScatterMin"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "squeeze"
  inputFrameworkOpName: "Squeeze"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Squeeze"
  }
  rule {
    ruleName: "listnumbertondarray"
    functionName: "listnumbertondarray"
    inputToOutput {
      key: "a"
      value: "squeeze_dims"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Squeeze"
  }
  rule {
    ruleName: "listnumbertolistnumber"
    functionName: "listnumbertolistnumber"
    outputIntName: "_a"
    inputToOutput {
      key: "_a"
      value: "squeeze_dims"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Squeeze"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "stack"
  inputFrameworkOpName: "Pack"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "values"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "values"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Pack"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "axis"
    outputIntName: "dimensions"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dimensions"
      value: "axis"
    }
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Pack"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "unsorted_segment_prod"
  inputFrameworkOpName: "UnsortedSegmentProd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "segment_ids"
    outputTensorName: "input"
    outputTensorName: "idxSegments"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "idxSegments"
      value: "segment_ids"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "UnsortedSegmentProd"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputIntName: "numSegments"
    inputToOutput {
      key: "numSegments"
      value: "num_segments"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "UnsortedSegmentProd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "subtract"
  inputFrameworkOpName: "Sub"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Sub"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Sub"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Sub"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "not_equals"
  inputFrameworkOpName: "NotEqual"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "NotEqual"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "NotEqual"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "NotEqual"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "expm1"
  inputFrameworkOpName: "Expm1"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Expm1"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Expm1"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Expm1"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "relu6"
  inputFrameworkOpName: "Relu6"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "features"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "features"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Relu6"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Relu6"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "cutoff"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
      transformerArgs {
        name: "cutoff"
        argType: DOUBLE
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
      transformerArgs {
        name: "cutoff"
        argType: DOUBLE
      }
    }
    inputFrameworkOpName: "Relu6"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "reduce_sum"
  inputFrameworkOpName: "Sum"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Sum"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "keep_dims"
    outputBooleanName: "keepDims"
    inputToOutput {
      key: "keepDims"
      value: "keep_dims"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Sum"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    inputToOutput {
      key: "dimensions"
      value: "reduction_indices"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Sum"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "dynamic_stitch"
  inputFrameworkOpName: "DynamicStitch"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "indices"
    outputTensorName: "index"
    outputTensorName: "input"
    inputToOutput {
      key: "index"
      value: "data"
    }
    inputToOutput {
      key: "input"
      value: "indices"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "DynamicStitch"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "N"
    outputIntName: "numPartitions"
    inputToOutput {
      key: "numPartitions"
      value: "N"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "DynamicStitch"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "argmax"
  inputFrameworkOpName: "ArgMax"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ArgMax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "keepDims"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "keepDims"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ArgMax"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "expand_dims"
  inputFrameworkOpName: "ExpandDims"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ExpandDims"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "dimensions"
    inputToOutput {
      key: "dimensions"
      value: "dim"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ExpandDims"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "reduce_min"
  inputFrameworkOpName: "Min"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Min"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "keep_dims"
    outputBooleanName: "keepDims"
    inputToOutput {
      key: "keepDims"
      value: "keep_dims"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Min"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    inputToOutput {
      key: "dimensions"
      value: "reduction_indices"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Min"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "space_to_batch"
  inputFrameworkOpName: "SpaceToBatch"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "paddings"
    outputTensorName: "input"
    outputTensorName: "padding"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "padding"
      value: "paddings"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SpaceToBatch"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "block_size"
    outputIntName: "blockSize"
    inputToOutput {
      key: "blockSize"
      value: "block_size"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "SpaceToBatch"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "bitwise_xor"
  inputFrameworkOpName: "BitwiseXor"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BitwiseXor"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "BitwiseXor"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "concat"
  inputFrameworkOpName: "ParallelConcat"
  rule {
    ruleName: "multiinputindex"
    functionName: "multiinputindex"
    inputTensorName: "values"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "values"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ParallelConcat"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "isDynamicAxis"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "isDynamicAxis"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ParallelConcat"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ParallelConcat"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "concatDimension"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "concatDimension"
        argType: INT64
      }
    }
    inputFrameworkOpName: "ParallelConcat"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_list"
  inputFrameworkOpName: "TensorArrayScatterV3"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "value"
    inputTensorName: "indices"
    inputTensorName: "flow_in"
    outputTensorName: "array"
    outputTensorName: "sizes"
    outputTensorName: "list"
    inputToOutput {
      key: "array"
      value: "value"
    }
    inputToOutput {
      key: "sizes"
      value: "indices"
    }
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayScatterV3"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArrayScatterV3"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_list"
  inputFrameworkOpName: "TensorArrayScatterV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "value"
    inputTensorName: "indices"
    inputTensorName: "flow_in"
    outputTensorName: "array"
    outputTensorName: "sizes"
    outputTensorName: "list"
    inputToOutput {
      key: "array"
      value: "value"
    }
    inputToOutput {
      key: "sizes"
      value: "indices"
    }
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayScatterV2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArrayScatterV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "Pow"
  inputFrameworkOpName: "Pow"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Pow"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "split"
  inputFrameworkOpName: "Split"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "split_dim"
    inputTensorName: "value"
    outputTensorName: "a"
    outputTensorName: "b"
    inputToOutput {
      key: "a"
      value: "split_dim"
    }
    inputToOutput {
      key: "b"
      value: "value"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Split"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "num_split"
    outputIntName: "numSplit"
    inputToOutput {
      key: "numSplit"
      value: "num_split"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Split"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "dimensions"
    inputToOutput {
      key: "dimensions"
      value: "split_dim"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Split"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "Where"
  inputFrameworkOpName: "Where"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "condition"
    inputToOutput {
      key: "condition"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Where"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "svd"
  inputFrameworkOpName: "Svd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Svd"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    outputIntName: "fullUV"
    inputBooleanName: "compute_uv"
    inputBooleanName: "full_matrices"
    outputBooleanName: "computeUv"
    inputToOutput {
      key: "computeUv"
      value: "compute_uv"
    }
    inputToOutput {
      key: "fullUV"
      value: "full_matrices"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Svd"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    outputIntName: "calcUV"
    outputIntName: "fullUV"
    inputBooleanName: "compute_uv"
    inputBooleanName: "full_matrices"
    inputToOutput {
      key: "calcUV"
      value: "compute_uv"
    }
    inputToOutput {
      key: "fullUV"
      value: "full_matrices"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Svd"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "switchNum"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "switchNum"
        int64Value: 16
        argType: INT64
        argIndex: 2
      }
    }
    inputFrameworkOpName: "Svd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "acosh"
  inputFrameworkOpName: "Acosh"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Acosh"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Acosh"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Acosh"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "placeholder"
  inputFrameworkOpName: "Placeholder"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    ruleType: "tensor"
    inputFrameworkOpName: "Placeholder"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "polygamma"
  inputFrameworkOpName: "Polygamma"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "a"
    inputTensorName: "x"
    outputTensorName: "n"
    outputTensorName: "input"
    inputToOutput {
      key: "n"
      value: "a"
    }
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Polygamma"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "equals"
  inputFrameworkOpName: "ApproximateEqual"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ApproximateEqual"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ApproximateEqual"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "stop_gradient"
  inputFrameworkOpName: "StopGradient"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "StopGradient"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "StopGradient"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_add"
  inputFrameworkOpName: "TensorScatterAdd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "tensor"
    inputTensorName: "indices"
    inputTensorName: "updates"
    outputTensorName: "input"
    outputTensorName: "indices"
    outputTensorName: "updates"
    inputToOutput {
      key: "input"
      value: "tensor"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorScatterAdd"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "lock"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "lock"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "TensorScatterAdd"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "checkIndices"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "checkIndices"
        argType: BOOL
        argIndex: 1
      }
    }
    inputFrameworkOpName: "TensorScatterAdd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "avgpool2d"
  inputFrameworkOpName: "AvgPool"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "value"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "value"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "AvgPool"
  }
  rule {
    ruleName: "stringnotequalsadapterrule"
    functionName: "stringnotequalsadapterrule"
    inputStringAttrName: "data_format"
    outputIntName: "isNCHW"
    inputFloatName: "data_format"
    inputToOutput {
      key: "isNCHW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNCHW"
      transformerArgs {
        name: "data_format"
        argIndex: 10
        stringValue: "NCHW"
      }
    }
    inputFrameworkOpName: "AvgPool"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputIntName: "isSameMode"
    inputToOutput {
      key: "isSameMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isSameMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        argIndex: 8
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "AvgPool"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "sH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "AvgPool"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "sW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "AvgPool"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "kH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "kH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    inputFrameworkOpName: "AvgPool"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "kW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "kW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    inputFrameworkOpName: "AvgPool"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pH"
    inputIntName: "pW"
    inputIntName: "dW"
    inputIntName: "dH"
    inputIntName: "extraParam0"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
      transformerArgs {
        name: "dW"
        int64Value: 1
        argType: INT64
        argIndex: 6
      }
      transformerArgs {
        name: "dH"
        int64Value: 1
        argType: INT64
        argIndex: 7
      }
      transformerArgs {
        name: "extraParam0"
        argType: INT64
        argIndex: 9
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
      transformerArgs {
        name: "dW"
        int64Value: 1
        argType: INT64
        argIndex: 6
      }
      transformerArgs {
        name: "dH"
        int64Value: 1
        argType: INT64
        argIndex: 7
      }
      transformerArgs {
        name: "extraParam0"
        argType: INT64
        argIndex: 9
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
      transformerArgs {
        name: "dW"
        int64Value: 1
        argType: INT64
        argIndex: 6
      }
      transformerArgs {
        name: "dH"
        int64Value: 1
        argType: INT64
        argIndex: 7
      }
      transformerArgs {
        name: "extraParam0"
        argType: INT64
        argIndex: 9
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
      transformerArgs {
        name: "dW"
        int64Value: 1
        argType: INT64
        argIndex: 6
      }
      transformerArgs {
        name: "dH"
        int64Value: 1
        argType: INT64
        argIndex: 7
      }
      transformerArgs {
        name: "extraParam0"
        argType: INT64
        argIndex: 9
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
      transformerArgs {
        name: "dW"
        int64Value: 1
        argType: INT64
        argIndex: 6
      }
      transformerArgs {
        name: "dH"
        int64Value: 1
        argType: INT64
        argIndex: 7
      }
      transformerArgs {
        name: "extraParam0"
        argType: INT64
        argIndex: 9
      }
    }
    inputFrameworkOpName: "AvgPool"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "unique_with_counts"
  inputFrameworkOpName: "UniqueWithCountsV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "UniqueWithCountsV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "depthwise_conv2d"
  inputFrameworkOpName: "DepthwiseConv2dNative"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "filter"
    outputTensorName: "input"
    outputTensorName: "weights"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "weights"
      value: "filter"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "DepthwiseConv2dNative"
  }
  rule {
    ruleName: "stringnotequalsadapterrule"
    functionName: "stringnotequalsadapterrule"
    inputStringAttrName: "data_format"
    outputIntName: "isNCHW"
    inputFloatName: "data_format"
    inputToOutput {
      key: "isNCHW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNCHW"
      transformerArgs {
        name: "data_format"
        argIndex: 9
        stringValue: "NCHW"
      }
    }
    inputFrameworkOpName: "DepthwiseConv2dNative"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputIntName: "isSameMode"
    inputToOutput {
      key: "isSameMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isSameMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        argIndex: 8
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "DepthwiseConv2dNative"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "sH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "DepthwiseConv2dNative"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "sW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "DepthwiseConv2dNative"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "dH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "dH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    inputFrameworkOpName: "DepthwiseConv2dNative"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "dW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "dW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    inputFrameworkOpName: "DepthwiseConv2dNative"
  }
  rule {
    ruleName: "ndarraysizeat"
    functionName: "ndarraysizeat"
    outputIntName: "kH"
    inputFloatName: "filter"
    inputToOutput {
      key: "kH"
      value: "filter"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "filter"
      }
    }
    inputFrameworkOpName: "DepthwiseConv2dNative"
  }
  rule {
    ruleName: "ndarraysizeat"
    functionName: "ndarraysizeat"
    outputIntName: "kW"
    inputFloatName: "filter"
    inputToOutput {
      key: "kW"
      value: "filter"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "filter"
        int64Value: 1
        argIndex: 1
      }
    }
    inputFrameworkOpName: "DepthwiseConv2dNative"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pH"
    inputIntName: "pW"
    inputIntName: "wFormat"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
      transformerArgs {
        name: "wFormat"
        argType: INT64
        argIndex: 10
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
      transformerArgs {
        name: "wFormat"
        argType: INT64
        argIndex: 10
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
      transformerArgs {
        name: "wFormat"
        argType: INT64
        argIndex: 10
      }
    }
    inputFrameworkOpName: "DepthwiseConv2dNative"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "log_matrix_determinant"
  inputFrameworkOpName: "LogMatrixDeterminant"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LogMatrixDeterminant"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "LogMatrixDeterminant"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "realdiv"
  inputFrameworkOpName: "RealDiv"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RealDiv"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "RealDiv"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RealDiv"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "abs"
  inputFrameworkOpName: "Abs"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Abs"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Abs"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Abs"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "identity"
  inputFrameworkOpName: "VariableV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    ruleType: "tensor"
    inputFrameworkOpName: "VariableV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "VariableV2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "VariableV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matrix_determinant"
  inputFrameworkOpName: "BatchMatrixDeterminant"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BatchMatrixDeterminant"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "MatrixDeterminant"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "maxpool3dnew"
  inputFrameworkOpName: "MaxPool3D"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "extraParam0"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "extraParam0"
        argType: INT64
        argIndex: 13
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pD"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pD"
        argType: INT64
        argIndex: 6
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 7
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 8
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dD"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dD"
        int64Value: 1
        argType: INT64
        argIndex: 9
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dH"
        int64Value: 1
        argType: INT64
        argIndex: 10
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dW"
        int64Value: 1
        argType: INT64
        argIndex: 11
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "data_format"
    inputStringAttrName: "data_format"
    outputIntName: "isNCDHW"
    inputToOutput {
      key: "isNCDHW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNCDHW"
      transformerArgs {
        name: "data_format"
        argType: STRING
        argIndex: 14
        stringValue: "NDHWC"
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputIntName: "isSameMode"
    inputToOutput {
      key: "isSameMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isSameMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        argIndex: 12
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "kH"
    inputToOutput {
      key: "kH"
      value: "ksize"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "index"
        int64Value: 3
        argType: INT64
        argIndex: 2
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "kW"
    inputToOutput {
      key: "kW"
      value: "ksize"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "index"
        int64Value: 2
        argType: INT64
        argIndex: 1
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "kD"
    inputToOutput {
      key: "kD"
      value: "ksize"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kD"
      transformerArgs {
        name: "index"
        int64Value: 1
        argType: INT64
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "sH"
    inputToOutput {
      key: "sH"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "index"
        int64Value: 3
        argType: INT64
        argIndex: 5
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "sW"
    inputToOutput {
      key: "sW"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "index"
        int64Value: 2
        argType: INT64
        argIndex: 4
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "sD"
    inputToOutput {
      key: "sD"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sD"
      transformerArgs {
        name: "index"
        int64Value: 1
        argType: INT64
        argIndex: 3
      }
    }
    inputFrameworkOpName: "MaxPool3D"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "tensorarraywritev3"
  inputFrameworkOpName: "TensorArrayWriteV3"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "handle"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "handle"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayWriteV3"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "softmax_cross_entropy_loss_with_logits"
  inputFrameworkOpName: "SoftmaxCrossEntropyWithLogits"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "labels"
    inputTensorName: "features"
    outputTensorName: "labels"
    outputTensorName: "logits"
    inputToOutput {
      key: "labels"
      value: "labels"
    }
    inputToOutput {
      key: "logits"
      value: "features"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SoftmaxCrossEntropyWithLogits"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "SoftmaxCrossEntropyWithLogits"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "segment_max"
  inputFrameworkOpName: "SegmentMax"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "segment_ids"
    outputTensorName: "input"
    outputTensorName: "idxSegments"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "idxSegments"
      value: "segment_ids"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SegmentMax"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "conv3dnew"
  inputFrameworkOpName: "Conv3D"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "filter"
    outputTensorName: "input"
    outputTensorName: "weights"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "weights"
      value: "filter"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "data_format"
    inputStringAttrName: "data_format"
    outputIntName: "isNCDHW"
    inputToOutput {
      key: "isNCDHW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNCDHW"
      transformerArgs {
        name: "data_format"
        argType: STRING
        argIndex: 13
        stringValue: "NDHWC"
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputIntName: "paddingMode"
    inputToOutput {
      key: "paddingMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "paddingMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        argIndex: 12
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "ndarraysizeat"
    functionName: "ndarraysizeat"
    outputIntName: "kD"
    inputFloatName: "filter"
    inputToOutput {
      key: "kD"
      value: "filter"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kD"
      transformerArgs {
        name: "filter"
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "ndarraysizeat"
    functionName: "ndarraysizeat"
    outputIntName: "kH"
    inputFloatName: "filter"
    inputToOutput {
      key: "kH"
      value: "filter"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "filter"
        int64Value: 1
        argIndex: 1
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "ndarraysizeat"
    functionName: "ndarraysizeat"
    outputIntName: "kW"
    inputFloatName: "filter"
    inputToOutput {
      key: "kW"
      value: "filter"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "filter"
        int64Value: 2
        argIndex: 2
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "sD"
    inputToOutput {
      key: "sD"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sD"
      transformerArgs {
        name: "index"
        int64Value: 1
        argType: INT64
        argIndex: 3
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "sH"
    inputToOutput {
      key: "sH"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "index"
        int64Value: 2
        argType: INT64
        argIndex: 4
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "sW"
    inputToOutput {
      key: "sW"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "index"
        int64Value: 3
        argType: INT64
        argIndex: 5
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 7
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 8
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 6
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "dH"
    inputToOutput {
      key: "dH"
      value: "dilations"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "index"
        int64Value: 3
        argType: INT64
        argIndex: 11
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "dW"
    inputToOutput {
      key: "dW"
      value: "dilations"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "index"
        int64Value: 2
        argType: INT64
        argIndex: 10
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "dD"
    inputToOutput {
      key: "dD"
      value: "dilations"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dD"
      transformerArgs {
        name: "index"
        int64Value: 1
        argType: INT64
        argIndex: 9
      }
    }
    inputFrameworkOpName: "Conv3D"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_sub"
  inputFrameworkOpName: "ScatterSub"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    inputTensorName: "updates"
    inputTensorName: "ref"
    outputTensorName: "indices"
    outputTensorName: "updates"
    outputTensorName: "input"
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    inputToOutput {
      key: "input"
      value: "ref"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterSub"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "lock"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "lock"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ScatterSub"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "checkIndices"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "checkIndices"
        argType: BOOL
        argIndex: 1
      }
    }
    inputFrameworkOpName: "ScatterSub"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "loop_cond"
  inputFrameworkOpName: "LoopCond"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    ruleType: "tensor"
    inputFrameworkOpName: "LoopCond"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "reverse"
  inputFrameworkOpName: "ReverseV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "tensor"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "tensor"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ReverseV2"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    inputToOutput {
      key: "dimensions"
      value: "axis"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ReverseV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "rank"
  inputFrameworkOpName: "Rank"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Rank"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Rank"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "erfc"
  inputFrameworkOpName: "Erfc"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Erfc"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Erfc"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Erfc"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "divide"
  inputFrameworkOpName: "Div"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Div"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Div"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Div"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "pad"
  inputFrameworkOpName: "Pad"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "paddings"
    outputTensorName: "input"
    outputTensorName: "paddings"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "paddings"
      value: "paddings"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Pad"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "mode"
    inputFloatName: "padValue"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "mode"
        argType: INT64
      }
      transformerArgs {
        name: "padValue"
        argType: DOUBLE
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "mode"
        argType: INT64
      }
      transformerArgs {
        name: "padValue"
        argType: DOUBLE
      }
    }
    inputFrameworkOpName: "Pad"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "sparse_softmax_cross_entropy_loss_with_logits"
  inputFrameworkOpName: "SparseSoftmaxCrossEntropyWithLogits"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "labels"
    inputTensorName: "features"
    outputTensorName: "labels"
    outputTensorName: "logits"
    inputToOutput {
      key: "labels"
      value: "labels"
    }
    inputToOutput {
      key: "logits"
      value: "features"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SparseSoftmaxCrossEntropyWithLogits"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "SparseSoftmaxCrossEntropyWithLogits"
  }
  indexOverrides {
    key: 1
    value: 0
  }
  indexOverrides {
    key: 0
    value: 1
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "merge"
  inputFrameworkOpName: "Merge"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "inputs"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "inputs"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Merge"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "resize_nearest_neighbor"
  inputFrameworkOpName: "ResizeNearestNeighbor"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    inputTensorName: "size"
    outputTensorName: "image"
    outputTensorName: "newImageSize"
    inputToOutput {
      key: "image"
      value: "images"
    }
    inputToOutput {
      key: "newImageSize"
      value: "size"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ResizeNearestNeighbor"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "align_corners"
    inputBooleanName: "half_pixel_centers"
    outputBooleanName: "alignCorners"
    outputBooleanName: "halfPixelCenter"
    inputToOutput {
      key: "alignCorners"
      value: "align_corners"
    }
    inputToOutput {
      key: "halfPixelCenter"
      value: "half_pixel_centers"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ResizeNearestNeighbor"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_min"
  inputFrameworkOpName: "ScatterMin"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "ref"
    inputTensorName: "indices"
    inputTensorName: "updates"
    outputTensorName: "input"
    outputTensorName: "indices"
    outputTensorName: "updates"
    inputToOutput {
      key: "input"
      value: "ref"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterMin"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "check_numerics"
  inputFrameworkOpName: "CheckNumericsV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "tensor"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "tensor"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "CheckNumericsV2"
  }
  rule {
    ruleName: "convertinputstringtondarray"
    functionName: "convertinputstringtondarray"
    inputStringAttrName: "message"
    inputToOutput {
      key: "message"
      value: "message"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "CheckNumericsV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "select"
  inputFrameworkOpName: "Select"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "condition"
    inputTensorName: "t"
    inputTensorName: "e"
    outputTensorName: "cond"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "cond"
      value: "condition"
    }
    inputToOutput {
      key: "input"
      value: "t"
    }
    inputToOutput {
      key: "y"
      value: "e"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Select"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "assign"
  inputFrameworkOpName: "Assign"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "ref"
    inputTensorName: "value"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "ref"
    }
    inputToOutput {
      key: "y"
      value: "value"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Assign"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "size_list"
  inputFrameworkOpName: "TensorArraySize"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "flow_in"
    outputTensorName: "list"
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArraySize"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "rint"
  inputFrameworkOpName: "Rint"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Rint"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Rint"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Rint"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "dilation2d"
  inputFrameworkOpName: "Dilation2D"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "filter"
    outputTensorName: "input"
    outputTensorName: "weights"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "weights"
      value: "filter"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Dilation2D"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputBooleanName: "isSameMode"
    inputToOutput {
      key: "isSameMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isSameMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "Dilation2D"
  }
  rule {
    ruleName: "listnumbertolistnumber"
    functionName: "listnumbertolistnumber"
    outputIntName: "rates"
    inputToOutput {
      key: "rates"
      value: "rates"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Dilation2D"
  }
  rule {
    ruleName: "listnumbertolistnumber"
    functionName: "listnumbertolistnumber"
    outputIntName: "strides"
    inputToOutput {
      key: "strides"
      value: "strides"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Dilation2D"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "avgpool3dnew"
  inputFrameworkOpName: "AvgPool3D"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "extraParam0"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "extraParam0"
        argType: INT64
        argIndex: 13
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pD"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pD"
        argType: INT64
        argIndex: 6
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 7
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 8
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dD"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dD"
        int64Value: 1
        argType: INT64
        argIndex: 9
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dH"
        int64Value: 1
        argType: INT64
        argIndex: 10
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dW"
        int64Value: 1
        argType: INT64
        argIndex: 11
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "data_format"
    inputStringAttrName: "data_format"
    outputIntName: "isNCDHW"
    inputToOutput {
      key: "isNCDHW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNCDHW"
      transformerArgs {
        name: "data_format"
        argType: STRING
        argIndex: 14
        stringValue: "NDHWC"
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputIntName: "isSameMode"
    inputToOutput {
      key: "isSameMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isSameMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        argIndex: 12
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "kH"
    inputToOutput {
      key: "kH"
      value: "ksize"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "index"
        int64Value: 3
        argType: INT64
        argIndex: 2
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "kW"
    inputToOutput {
      key: "kW"
      value: "ksize"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "index"
        int64Value: 2
        argType: INT64
        argIndex: 1
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "kD"
    inputToOutput {
      key: "kD"
      value: "ksize"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kD"
      transformerArgs {
        name: "index"
        int64Value: 1
        argType: INT64
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "sH"
    inputToOutput {
      key: "sH"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "index"
        int64Value: 3
        argType: INT64
        argIndex: 5
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "sW"
    inputToOutput {
      key: "sW"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "index"
        int64Value: 2
        argType: INT64
        argIndex: 4
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "sD"
    inputToOutput {
      key: "sD"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sD"
      transformerArgs {
        name: "index"
        int64Value: 1
        argType: INT64
        argIndex: 3
      }
    }
    inputFrameworkOpName: "AvgPool3D"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "add"
  inputFrameworkOpName: "Add"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Add"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Add"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Add"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "isfinite"
  inputFrameworkOpName: "IsFinite"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "IsFinite"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "IsFinite"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matrix_inverse"
  inputFrameworkOpName: "BatchMatrixInverse"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BatchMatrixInverse"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        boolValue: true
        argType: BOOL
      }
    }
    inputFrameworkOpName: "BatchMatrixInverse"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "rshift_bits"
  inputFrameworkOpName: "RightShift"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RightShift"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "RightShift"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RightShift"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "elu"
  inputFrameworkOpName: "Elu"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "features"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "features"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Elu"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "alpha"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "alpha"
        doubleValue: 1.0
        argType: DOUBLE
      }
    }
    inputFrameworkOpName: "Elu"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matrix_diag"
  inputFrameworkOpName: "MatrixDiag"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "diagonal"
    outputTensorName: "diagonal"
    inputToOutput {
      key: "diagonal"
      value: "diagonal"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MatrixDiag"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "MatrixDiag"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "draw_bounding_boxes"
  inputFrameworkOpName: "DrawBoundingBoxesV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    inputTensorName: "boxes"
    inputTensorName: "colors"
    outputTensorName: "images"
    outputTensorName: "boxes"
    outputTensorName: "colors"
    inputToOutput {
      key: "images"
      value: "images"
    }
    inputToOutput {
      key: "boxes"
      value: "boxes"
    }
    inputToOutput {
      key: "colors"
      value: "colors"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "DrawBoundingBoxesV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "igamma"
  inputFrameworkOpName: "Igamma"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "a"
    inputTensorName: "x"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "a"
    }
    inputToOutput {
      key: "y"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Igamma"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matmul"
  inputFrameworkOpName: "MatMul"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "a"
    inputTensorName: "b"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "a"
    }
    inputToOutput {
      key: "y"
      value: "b"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MatMul"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "alpha"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "alpha"
        doubleValue: 1.0
        argType: DOUBLE
      }
    }
    inputFrameworkOpName: "MatMul"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "beta"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "beta"
        argType: DOUBLE
        argIndex: 1
      }
    }
    inputFrameworkOpName: "MatMul"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    outputIntName: "transX"
    outputIntName: "transY"
    inputBooleanName: "transpose_a"
    inputBooleanName: "transpose_b"
    inputToOutput {
      key: "transX"
      value: "transpose_a"
    }
    inputToOutput {
      key: "transY"
      value: "transpose_b"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "MatMul"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "transZ"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "transZ"
        argType: INT64
        argIndex: 2
      }
    }
    inputFrameworkOpName: "MatMul"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "sinh"
  inputFrameworkOpName: "Sinh"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Sinh"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Sinh"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Sinh"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "softplus"
  inputFrameworkOpName: "Softplus"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "features"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "features"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Softplus"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Softplus"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "identity"
  inputFrameworkOpName: "Const"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    ruleType: "tensor"
    inputFrameworkOpName: "Const"
  }
  rule {
    ruleName: "ndarrayinputtondarray"
    functionName: "ndarrayinputtondarray"
    inputTensorName: "value"
    inputToOutput {
      key: "input"
      value: "value"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Const"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Const"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Const"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "cumsum"
  inputFrameworkOpName: "Cumsum"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "axis"
    outputTensorName: "input"
    outputTensorName: "dimensions"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "dimensions"
      value: "axis"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Cumsum"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    inputBooleanName: "exclusive"
    inputBooleanName: "reverse"
    outputBooleanName: "exclusive"
    outputBooleanName: "reverse"
    inputToOutput {
      key: "exclusive"
      value: "exclusive"
    }
    inputToOutput {
      key: "reverse"
      value: "reverse"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Cumsum"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "zeroslike"
  inputFrameworkOpName: "ZerosLike"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ZerosLike"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ZerosLike"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    outputIntName: "dataType"
    inputDataTypeName: "T"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ZerosLike"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "gather"
  inputFrameworkOpName: "Gather"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "params"
    inputTensorName: "indices"
    outputTensorName: "input"
    outputTensorName: "indices"
    inputToOutput {
      key: "input"
      value: "params"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Gather"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    ruleType: "attribute"
    inputFrameworkOpName: "Gather"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Gather"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dimensions"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dimensions"
        argType: INT64
      }
    }
    inputFrameworkOpName: "Gather"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "stack_list"
  inputFrameworkOpName: "TensorArrayConcat"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "flow_in"
    outputTensorName: "list"
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayConcat"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_nd_add"
  inputFrameworkOpName: "ScatterNdAdd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    inputTensorName: "updates"
    inputTensorName: "ref"
    outputTensorName: "indices"
    outputTensorName: "updates"
    outputTensorName: "input"
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    inputToOutput {
      key: "input"
      value: "ref"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterNdAdd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "bitcast"
  inputFrameworkOpName: "Bitcast"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Bitcast"
  }
  rule {
    ruleName: "datatypetoint"
    functionName: "datatypetoint"
    outputIntName: "newType"
    inputDataTypeName: "type"
    inputToOutput {
      key: "newType"
      value: "type"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Bitcast"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "type"
    inputToOutput {
      key: "dataType"
      value: "type"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Bitcast"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "bitwise_or"
  inputFrameworkOpName: "BitwiseOr"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BitwiseOr"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "BitwiseOr"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "gruCell"
  inputFrameworkOpName: "GRUBlockCell"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "h_prev"
    inputTensorName: "w_ru"
    inputTensorName: "w_c"
    inputTensorName: "b_ru"
    inputTensorName: "b_c"
    outputTensorName: "input"
    outputTensorName: "hLast"
    outputTensorName: "Wru"
    outputTensorName: "Wc"
    outputTensorName: "bru"
    outputTensorName: "bc"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "hLast"
      value: "h_prev"
    }
    inputToOutput {
      key: "Wru"
      value: "w_ru"
    }
    inputToOutput {
      key: "Wc"
      value: "w_c"
    }
    inputToOutput {
      key: "bru"
      value: "b_ru"
    }
    inputToOutput {
      key: "bc"
      value: "b_c"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "GRUBlockCell"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "randomuniform"
  inputFrameworkOpName: "RandomUniform"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "shape"
    outputTensorName: "shape"
    inputToOutput {
      key: "shape"
      value: "shape"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RandomUniform"
  }
  rule {
    ruleName: "datatypetoint"
    functionName: "datatypetoint"
    outputIntName: "dtype"
    inputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomUniform"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomUniform"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "min"
    inputFloatName: "max"
    inputTensorName: "min"
    inputTensorName: "max"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "min"
        argType: DOUBLE
      }
      transformerArgs {
        name: "max"
        doubleValue: 1.0
        argType: DOUBLE
        argIndex: 1
      }
      transformerArgs {
        name: "min"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 1
      }
      transformerArgs {
        name: "max"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 2
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "min"
        argType: DOUBLE
      }
      transformerArgs {
        name: "max"
        doubleValue: 1.0
        argType: DOUBLE
        argIndex: 1
      }
      transformerArgs {
        name: "min"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 1
      }
      transformerArgs {
        name: "max"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 2
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "min"
        argType: DOUBLE
      }
      transformerArgs {
        name: "max"
        doubleValue: 1.0
        argType: DOUBLE
        argIndex: 1
      }
      transformerArgs {
        name: "min"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 1
      }
      transformerArgs {
        name: "max"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 2
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "min"
        argType: DOUBLE
      }
      transformerArgs {
        name: "max"
        doubleValue: 1.0
        argType: DOUBLE
        argIndex: 1
      }
      transformerArgs {
        name: "min"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 1
      }
      transformerArgs {
        name: "max"
        inputValue {
          data_type: 11
          double_data: 1.0
        }
        argType: INPUT_TENSOR
        argIndex: 2
      }
    }
    inputFrameworkOpName: "RandomUniform"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "bitwise_and"
  inputFrameworkOpName: "BitwiseAnd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BitwiseAnd"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "BitwiseAnd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "enter"
  inputFrameworkOpName: "Enter"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "data"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Enter"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputStringAttrName: "frame_name"
    outputStringAttrName: "frameName"
    inputBooleanName: "is_constant"
    outputBooleanName: "isConstant"
    inputToOutput {
      key: "isConstant"
      value: "is_constant"
    }
    inputToOutput {
      key: "frameName"
      value: "frame_name"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Enter"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "sin"
  inputFrameworkOpName: "Sin"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Sin"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Sin"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Sin"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "unique"
  inputFrameworkOpName: "Unique"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Unique"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "roll"
  inputFrameworkOpName: "Roll"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "axis"
    inputTensorName: "shift"
    outputTensorName: "input"
    outputTensorName: "dimensions"
    outputTensorName: "shiftsI"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "dimensions"
      value: "axis"
    }
    inputToOutput {
      key: "shiftsI"
      value: "shift"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Roll"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "shift"
    inputToOutput {
      key: "shift"
      value: "shift"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Roll"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "in_top_k"
  inputFrameworkOpName: "InTopK"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "targets"
    inputTensorName: "predictions"
    outputTensorName: "target"
    outputTensorName: "predictions"
    inputToOutput {
      key: "target"
      value: "targets"
    }
    inputToOutput {
      key: "predictions"
      value: "predictions"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "InTopK"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "k"
    outputIntName: "k"
    inputToOutput {
      key: "k"
      value: "k"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "InTopK"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "sorted"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "sorted"
        boolValue: true
        argType: BOOL
      }
    }
    inputFrameworkOpName: "InTopK"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "reverse_sequence"
  inputFrameworkOpName: "ReverseSequence"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "seq_lengths"
    outputTensorName: "input"
    outputTensorName: "seqLengths"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "seqLengths"
      value: "seq_lengths"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ReverseSequence"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "batch_dim"
    inputIntName: "seq_dim"
    outputIntName: "batchDim"
    outputIntName: "seqDim"
    inputToOutput {
      key: "batchDim"
      value: "batch_dim"
    }
    inputToOutput {
      key: "seqDim"
      value: "seq_dim"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ReverseSequence"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "unsorted_segment_min"
  inputFrameworkOpName: "UnsortedSegmentMin"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "segment_ids"
    outputTensorName: "input"
    outputTensorName: "idxSegments"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "idxSegments"
      value: "segment_ids"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "UnsortedSegmentMin"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputIntName: "numSegments"
    inputToOutput {
      key: "numSegments"
      value: "num_segments"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "UnsortedSegmentMin"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "rsqrt"
  inputFrameworkOpName: "Rsqrt"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Rsqrt"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Rsqrt"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Rsqrt"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "split_list"
  inputFrameworkOpName: "TensorArraySplit"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "lengths"
    inputTensorName: "value"
    inputTensorName: "value"
    outputTensorName: "sizes"
    outputTensorName: "list"
    outputTensorName: "array"
    inputToOutput {
      key: "sizes"
      value: "lengths"
    }
    inputToOutput {
      key: "list"
      value: "value"
    }
    inputToOutput {
      key: "array"
      value: "value"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArraySplit"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArraySplit"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_nd_update"
  inputFrameworkOpName: "ScatterNdUpdate"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    inputTensorName: "updates"
    inputTensorName: "ref"
    outputTensorName: "indices"
    outputTensorName: "updates"
    outputTensorName: "input"
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    inputToOutput {
      key: "input"
      value: "ref"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterNdUpdate"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "rgb_to_hsv"
  inputFrameworkOpName: "RGBToHSV"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "images"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RGBToHSV"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "create"
  inputFrameworkOpName: "Empty"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "shape"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "shape"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Empty"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "init"
    outputBooleanName: "init"
    inputDataTypeName: "dtype"
    outputDataTypeName: "outputType"
    inputToOutput {
      key: "init"
      value: "init"
    }
    inputToOutput {
      key: "outputType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Empty"
  }
  rule {
    ruleName: "datatypetoint"
    functionName: "datatypetoint"
    inputDataTypeName: "dtype"
    outputDataTypeName: "outputType"
    inputToOutput {
      key: "outputType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Empty"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "order"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "order"
        int64Value: 99
        argType: INT64
      }
    }
    inputFrameworkOpName: "Empty"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "zeta"
  inputFrameworkOpName: "Zeta"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "q"
    outputTensorName: "input"
    outputTensorName: "q"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "q"
      value: "q"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Zeta"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Zeta"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "lin_space"
  inputFrameworkOpName: "LinSpace"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "start"
    inputTensorName: "stop"
    inputTensorName: "num"
    outputTensorName: "start"
    outputTensorName: "finish"
    outputTensorName: "numOfElements"
    inputToOutput {
      key: "start"
      value: "start"
    }
    inputToOutput {
      key: "finish"
      value: "stop"
    }
    inputToOutput {
      key: "numOfElements"
      value: "num"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LinSpace"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputDoubleName: "stop"
    inputToOutput {
      key: "start"
      value: "start"
    }
    inputToOutput {
      key: "stop"
      value: "stop"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "LinSpace"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "LinSpace"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "boolean_and"
  inputFrameworkOpName: "LogicalAnd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LogicalAnd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "random_gamma"
  inputFrameworkOpName: "RandomGamma"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "shape"
    inputTensorName: "alpha"
    outputTensorName: "shape"
    outputTensorName: "alpha"
    inputToOutput {
      key: "shape"
      value: "shape"
    }
    inputToOutput {
      key: "alpha"
      value: "alpha"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RandomGamma"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "seed"
    outputIntName: "seed"
    inputToOutput {
      key: "seed"
      value: "seed"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomGamma"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "pad"
  inputFrameworkOpName: "PadV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "paddings"
    outputTensorName: "input"
    outputTensorName: "paddings"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "paddings"
      value: "paddings"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "PadV2"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputDoubleName: "padValue"
    inputToOutput {
      key: "padValue"
      value: "constant_values"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "PadV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "mode"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "mode"
        argType: INT64
      }
    }
    inputFrameworkOpName: "PadV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "unsorted_segment_sum"
  inputFrameworkOpName: "UnsortedSegmentSum"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "segment_ids"
    outputTensorName: "input"
    outputTensorName: "idxSegments"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "idxSegments"
      value: "segment_ids"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "UnsortedSegmentSum"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputIntName: "numSegments"
    inputToOutput {
      key: "numSegments"
      value: "num_segments"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "UnsortedSegmentSum"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "log1p"
  inputFrameworkOpName: "Log1p"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Log1p"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Log1p"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Log1p"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matrix_set_diag"
  inputFrameworkOpName: "MatrixSetDiag"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "diagonal"
    outputTensorName: "input"
    outputTensorName: "diagonal"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "diagonal"
      value: "diagonal"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MatrixSetDiag"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "BatchMatrixSetDiag"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "dynamic_partition"
  inputFrameworkOpName: "DynamicPartition"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "partitions"
    outputTensorName: "input"
    outputTensorName: "indices"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "indices"
      value: "partitions"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "DynamicPartition"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "num_partitions"
    outputIntName: "numPartitions"
    inputToOutput {
      key: "numPartitions"
      value: "num_partitions"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "DynamicPartition"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "mod"
  inputFrameworkOpName: "Mod"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Mod"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Mod"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Mod"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_mul"
  inputFrameworkOpName: "ScatterMul"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    inputTensorName: "updates"
    inputTensorName: "ref"
    outputTensorName: "indices"
    outputTensorName: "updates"
    outputTensorName: "input"
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    inputToOutput {
      key: "input"
      value: "ref"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterMul"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "broadcast_to"
  inputFrameworkOpName: "BroadcastTo"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "shape"
    outputTensorName: "input"
    outputTensorName: "shape"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "shape"
      value: "shape"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BroadcastTo"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "random_poisson"
  inputFrameworkOpName: "RandomPoissonV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "shape"
    inputTensorName: "rate"
    outputTensorName: "shape"
    outputTensorName: "lambda"
    inputToOutput {
      key: "shape"
      value: "shape"
    }
    inputToOutput {
      key: "lambda"
      value: "rate"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RandomPoissonV2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "seed"
    outputIntName: "seed"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "seed"
      value: "seed"
    }
    inputToOutput {
      key: "dtype"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomPoissonV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "asin"
  inputFrameworkOpName: "Asin"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Asin"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Asin"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Asin"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "space_to_depth"
  inputFrameworkOpName: "SpaceToDepth"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SpaceToDepth"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "block_size"
    outputIntName: "block_size"
    inputToOutput {
      key: "block_size"
      value: "block_size"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "SpaceToDepth"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "data_format"
    inputStringAttrName: "data_format"
    outputIntName: "isNHWC"
    inputToOutput {
      key: "isNHWC"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNHWC"
      transformerArgs {
        name: "data_format"
        argType: STRING
        argIndex: 1
        stringValue: "NHWC"
      }
    }
    inputFrameworkOpName: "SpaceToDepth"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "tile"
  inputFrameworkOpName: "Tile"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "multiples"
    outputTensorName: "input"
    outputTensorName: "reps_vector"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "reps_vector"
      value: "multiples"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Tile"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dimensions"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dimensions"
        argType: INT64
      }
    }
    inputFrameworkOpName: "Tile"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "is_static_reps"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "is_static_reps"
        boolValue: true
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Tile"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "depth_to_space"
  inputFrameworkOpName: "DepthToSpace"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "DepthToSpace"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "block_size"
    outputIntName: "block_size"
    inputToOutput {
      key: "block_size"
      value: "block_size"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "DepthToSpace"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "data_format"
    inputStringAttrName: "data_format"
    outputIntName: "isNHWC"
    inputToOutput {
      key: "isNHWC"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNHWC"
      transformerArgs {
        name: "data_format"
        argType: STRING
        argIndex: 1
        stringValue: "NHWC"
      }
    }
    inputFrameworkOpName: "DepthToSpace"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "invert_permutation"
  inputFrameworkOpName: "InvertPermutation"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "InvertPermutation"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "InvertPermutation"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "InvertPermutation"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "crop_and_resize"
  inputFrameworkOpName: "CropAndResize"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "image"
    inputTensorName: "boxes"
    inputTensorName: "box_ind"
    inputTensorName: "crop_size"
    outputTensorName: "image"
    outputTensorName: "boxes"
    outputTensorName: "boxIndexes"
    outputTensorName: "newImageSize"
    inputToOutput {
      key: "image"
      value: "image"
    }
    inputToOutput {
      key: "boxes"
      value: "boxes"
    }
    inputToOutput {
      key: "boxIndexes"
      value: "box_ind"
    }
    inputToOutput {
      key: "newImageSize"
      value: "crop_size"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "CropAndResize"
  }
  rule {
    ruleName: "stringtoindex"
    functionName: "stringtoindex"
    inputStringAttrName: "method"
    outputIntName: "method"
    inputFloatName: "bilinear"
    inputFloatName: "nearest"
    inputToOutput {
      key: "method"
      value: "method"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "method"
      transformerArgs {
        name: "bilinear"
        stringValue: "bilinear"
      }
      transformerArgs {
        name: "nearest"
        stringValue: "nearest"
      }
    }
    transformerArgs {
      key: "method"
      transformerArgs {
        name: "bilinear"
        stringValue: "bilinear"
      }
      transformerArgs {
        name: "nearest"
        stringValue: "nearest"
      }
    }
    inputFrameworkOpName: "CropAndResize"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputFloatName: "extrapolation_value"
    outputDoubleName: "extrapolationVal"
    inputToOutput {
      key: "extrapolationVal"
      value: "extrapolation_value"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "CropAndResize"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "read_list"
  inputFrameworkOpName: "TensorArrayRead"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "handle"
    outputTensorName: "list"
    inputToOutput {
      key: "list"
      value: "handle"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayRead"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "importDataType"
    inputToOutput {
      key: "importDataType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArrayRead"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_nd"
  inputFrameworkOpName: "ScatterNd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    inputTensorName: "updates"
    inputTensorName: "shape"
    outputTensorName: "indices"
    outputTensorName: "updates"
    outputTensorName: "shape"
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    inputToOutput {
      key: "shape"
      value: "shape"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterNd"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "lock"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "lock"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ScatterNd"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "checkIndices"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "checkIndices"
        argType: BOOL
        argIndex: 1
      }
    }
    inputFrameworkOpName: "ScatterNd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "strided_slice"
  inputFrameworkOpName: "StridedSlice"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "begin"
    inputTensorName: "end"
    inputTensorName: "strides"
    outputTensorName: "input"
    outputTensorName: "v_begin"
    outputTensorName: "v_end"
    outputTensorName: "v_stride"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "v_begin"
      value: "begin"
    }
    inputToOutput {
      key: "v_end"
      value: "end"
    }
    inputToOutput {
      key: "v_stride"
      value: "strides"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "StridedSlice"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "begin_mask"
    inputIntName: "end_mask"
    inputIntName: "ellipsis_mask"
    inputIntName: "new_axis_mask"
    inputIntName: "shrink_axis_mask"
    outputIntName: "begin_mask"
    outputIntName: "end_mask"
    outputIntName: "ellipsis_mask"
    outputIntName: "new_axis_mask"
    outputIntName: "shrink_axis_mask"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "begin_mask"
      value: "begin_mask"
    }
    inputToOutput {
      key: "end_mask"
      value: "end_mask"
    }
    inputToOutput {
      key: "ellipsis_mask"
      value: "ellipsis_mask"
    }
    inputToOutput {
      key: "new_axis_mask"
      value: "new_axis_mask"
    }
    inputToOutput {
      key: "shrink_axis_mask"
      value: "shrink_axis_mask"
    }
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "StridedSlice"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_list"
  inputFrameworkOpName: "TensorArrayScatter"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "value"
    inputTensorName: "indices"
    inputTensorName: "flow_in"
    outputTensorName: "array"
    outputTensorName: "sizes"
    outputTensorName: "list"
    inputToOutput {
      key: "array"
      value: "value"
    }
    inputToOutput {
      key: "sizes"
      value: "indices"
    }
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayScatter"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArrayScatter"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "size_list"
  inputFrameworkOpName: "TensorArraySizeV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "flow_in"
    outputTensorName: "list"
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArraySizeV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "size_list"
  inputFrameworkOpName: "TensorArraySizeV3"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "flow_in"
    outputTensorName: "list"
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArraySizeV3"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "next_iteration"
  inputFrameworkOpName: "NextIteration"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "data"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "NextIteration"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "solve"
  inputFrameworkOpName: "MatrixSolve"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "matrix"
    inputTensorName: "rhs"
    outputTensorName: "a"
    outputTensorName: "b"
    inputToOutput {
      key: "a"
      value: "matrix"
    }
    inputToOutput {
      key: "b"
      value: "rhs"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MatrixSolve"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "adjoint"
    outputBooleanName: "useAdjoint"
    inputToOutput {
      key: "useAdjoint"
      value: "adjoint"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "MatrixSolve"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "fused_batch_norm"
  inputFrameworkOpName: "FusedBatchNorm"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "scale"
    inputTensorName: "offset"
    inputTensorName: "mean"
    inputTensorName: "variance"
    outputTensorName: "input"
    outputTensorName: "scale"
    outputTensorName: "offset"
    outputTensorName: "mean"
    outputTensorName: "variance"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "scale"
      value: "scale"
    }
    inputToOutput {
      key: "offset"
      value: "offset"
    }
    inputToOutput {
      key: "mean"
      value: "mean"
    }
    inputToOutput {
      key: "variance"
      value: "variance"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "FusedBatchNorm"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputFloatName: "epsilon"
    outputDoubleName: "epsilon"
    inputToOutput {
      key: "epsilon"
      value: "epsilon"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FusedBatchNorm"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    outputIntName: "isTraining"
    inputBooleanName: "is_training"
    inputToOutput {
      key: "isTraining"
      value: "is_training"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FusedBatchNorm"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "data_format"
    inputStringAttrName: "data_format"
    outputIntName: "dataFormat"
    inputToOutput {
      key: "dataFormat"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dataFormat"
      transformerArgs {
        name: "data_format"
        argType: STRING
        stringValue: "NCHW"
      }
    }
    inputFrameworkOpName: "FusedBatchNorm"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_max"
  inputFrameworkOpName: "TensorScatterMax"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "tensor"
    inputTensorName: "indices"
    inputTensorName: "updates"
    outputTensorName: "input"
    outputTensorName: "indices"
    outputTensorName: "updates"
    inputToOutput {
      key: "input"
      value: "tensor"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorScatterMax"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "greater_equal"
  inputFrameworkOpName: "GreaterEqual"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "GreaterEqual"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "GreaterEqual"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "GreaterEqual"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_nd_sub"
  inputFrameworkOpName: "ScatterNdSub"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    inputTensorName: "updates"
    inputTensorName: "ref"
    outputTensorName: "indices"
    outputTensorName: "updates"
    outputTensorName: "input"
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    inputToOutput {
      key: "input"
      value: "ref"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterNdSub"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "equals"
  inputFrameworkOpName: "Equal"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Equal"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Equal"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "read_list"
  inputFrameworkOpName: "TensorArrayReadV3"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "handle"
    outputTensorName: "list"
    inputToOutput {
      key: "list"
      value: "handle"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayReadV3"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "importDataType"
    inputToOutput {
      key: "importDataType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArrayReadV3"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "floormod"
  inputFrameworkOpName: "FloorMod"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "FloorMod"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "FloorMod"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FloorMod"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "read_list"
  inputFrameworkOpName: "TensorArrayReadV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "handle"
    outputTensorName: "list"
    inputToOutput {
      key: "list"
      value: "handle"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayReadV2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "importDataType"
    inputToOutput {
      key: "importDataType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArrayReadV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "biasadd"
  inputFrameworkOpName: "BiasAdd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "value"
    inputTensorName: "bias"
    outputTensorName: "input"
    outputTensorName: "bias"
    inputToOutput {
      key: "input"
      value: "value"
    }
    inputToOutput {
      key: "bias"
      value: "bias"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BiasAdd"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "data_format"
    inputStringAttrName: "data_format"
    outputBooleanName: "nchw"
    inputToOutput {
      key: "nchw"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "nchw"
      transformerArgs {
        name: "data_format"
        argType: STRING
        stringValue: "NCHW"
      }
    }
    inputFrameworkOpName: "BiasAdd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "identity"
  inputFrameworkOpName: "Identity"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Identity"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Identity"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Identity"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "unstack"
  inputFrameworkOpName: "Unpack"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "value"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "value"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Unpack"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "axis"
    inputIntName: "num"
    outputIntName: "dimensions"
    outputIntName: "num"
    inputToOutput {
      key: "dimensions"
      value: "axis"
    }
    inputToOutput {
      key: "num"
      value: "num"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Unpack"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "exit"
  inputFrameworkOpName: "Exit"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "data"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Exit"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "add"
  inputFrameworkOpName: "AddV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "AddV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "AddV2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "AddV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "tanh"
  inputFrameworkOpName: "Tanh"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Tanh"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Tanh"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Tanh"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "toggle_bits"
  inputFrameworkOpName: "Invert"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Invert"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "lstmBlockCell"
  inputFrameworkOpName: "LSTMBlockCell"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "cs_prev"
    inputTensorName: "h_prev"
    inputTensorName: "w"
    inputTensorName: "wci"
    inputTensorName: "wcf"
    inputTensorName: "wco"
    inputTensorName: "b"
    outputTensorName: "xt"
    outputTensorName: "cLast"
    outputTensorName: "yLast"
    outputTensorName: "W"
    outputTensorName: "Wci"
    outputTensorName: "Wcf"
    outputTensorName: "Wco"
    outputTensorName: "b"
    inputToOutput {
      key: "xt"
      value: "x"
    }
    inputToOutput {
      key: "cLast"
      value: "cs_prev"
    }
    inputToOutput {
      key: "yLast"
      value: "h_prev"
    }
    inputToOutput {
      key: "W"
      value: "w"
    }
    inputToOutput {
      key: "Wci"
      value: "wci"
    }
    inputToOutput {
      key: "Wcf"
      value: "wcf"
    }
    inputToOutput {
      key: "Wco"
      value: "wco"
    }
    inputToOutput {
      key: "b"
      value: "b"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LSTMBlockCell"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputFloatName: "forget_bias"
    inputFloatName: "cell_clip"
    outputDoubleName: "forgetBias"
    outputDoubleName: "clippingCellValue"
    inputToOutput {
      key: "forgetBias"
      value: "forget_bias"
    }
    inputToOutput {
      key: "clippingCellValue"
      value: "cell_clip"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "LSTMBlockCell"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    outputIntName: "peephole"
    inputBooleanName: "use_peephole"
    inputToOutput {
      key: "peephole"
      value: "use_peephole"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "LSTMBlockCell"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "log"
  inputFrameworkOpName: "Log"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Log"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Log"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Log"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "non_max_suppression_v3"
  inputFrameworkOpName: "NonMaxSuppressionV4"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "boxes"
    inputTensorName: "scores"
    inputTensorName: "max_output_size"
    inputTensorName: "iou_threshold"
    inputTensorName: "score_threshold"
    outputTensorName: "boxes"
    outputTensorName: "scales"
    outputTensorName: "maxOutSize"
    outputTensorName: "iouThreshold"
    outputTensorName: "scoreThreshold"
    inputToOutput {
      key: "boxes"
      value: "boxes"
    }
    inputToOutput {
      key: "scales"
      value: "scores"
    }
    inputToOutput {
      key: "maxOutSize"
      value: "max_output_size"
    }
    inputToOutput {
      key: "iouThreshold"
      value: "iou_threshold"
    }
    inputToOutput {
      key: "scoreThreshold"
      value: "score_threshold"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "NonMaxSuppressionV4"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputIntName: "maxOutputSize"
    inputToOutput {
      key: "maxOutputSize"
      value: "max_output_size"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "NonMaxSuppressionV4"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "less_equal"
  inputFrameworkOpName: "LessEqual"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LessEqual"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "LessEqual"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "LessEqual"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "non_max_suppression"
  inputFrameworkOpName: "NonMaxSuppressionV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "boxes"
    inputTensorName: "scores"
    inputTensorName: "iou_threshold"
    inputTensorName: "max_output_size"
    outputTensorName: "boxes"
    outputTensorName: "scales"
    outputTensorName: "overlayThreshold"
    outputTensorName: "maxOutputSize"
    inputToOutput {
      key: "boxes"
      value: "boxes"
    }
    inputToOutput {
      key: "scales"
      value: "scores"
    }
    inputToOutput {
      key: "overlayThreshold"
      value: "iou_threshold"
    }
    inputToOutput {
      key: "maxOutputSize"
      value: "max_output_size"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "NonMaxSuppressionV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "scoreThreshold"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "scoreThreshold"
        doubleValue: 0.5
        argType: DOUBLE
        argIndex: 1
      }
    }
    inputFrameworkOpName: "NonMaxSuppressionV2"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    inputToOutput {
      key: "maxOutputSize"
      value: "max_output_size"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "NonMaxSuppressionV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "non_max_suppression_v3"
  inputFrameworkOpName: "NonMaxSuppressionV3"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "boxes"
    inputTensorName: "scores"
    inputTensorName: "max_output_size"
    inputTensorName: "iou_threshold"
    inputTensorName: "score_threshold"
    outputTensorName: "boxes"
    outputTensorName: "scales"
    outputTensorName: "maxOutSize"
    outputTensorName: "iouThreshold"
    outputTensorName: "scoreThreshold"
    inputToOutput {
      key: "boxes"
      value: "boxes"
    }
    inputToOutput {
      key: "scales"
      value: "scores"
    }
    inputToOutput {
      key: "maxOutSize"
      value: "max_output_size"
    }
    inputToOutput {
      key: "iouThreshold"
      value: "iou_threshold"
    }
    inputToOutput {
      key: "scoreThreshold"
      value: "score_threshold"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "NonMaxSuppressionV3"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputIntName: "maxOutputSize"
    inputToOutput {
      key: "maxOutputSize"
      value: "max_output_size"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "NonMaxSuppressionV3"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "onehot"
  inputFrameworkOpName: "OneHot"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "indices"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "OneHot"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    inputToOutput {
      key: "on"
      value: "on_value"
    }
    inputToOutput {
      key: "off"
      value: "off_value"
    }
    inputToOutput {
      key: "depth"
      value: "depth"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "OneHot"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "axis"
    outputIntName: "dimensions"
    outputIntName: "dataType"
    inputDataTypeName: "T"
    inputToOutput {
      key: "dimensions"
      value: "axis"
    }
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "OneHot"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "transpose"
  inputFrameworkOpName: "Transpose"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "perm"
    outputTensorName: "input"
    outputTensorName: "permutationVector"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "permutationVector"
      value: "perm"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Transpose"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Transpose"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "permuteDims"
    inputToOutput {
      key: "permuteDims"
      value: "perm"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Transpose"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "square"
  inputFrameworkOpName: "Square"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Square"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Square"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Square"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "segment_min"
  inputFrameworkOpName: "SegmentMin"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "segment_ids"
    outputTensorName: "input"
    outputTensorName: "idxSegments"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "idxSegments"
      value: "segment_ids"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SegmentMin"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "switch"
  inputFrameworkOpName: "Switch"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "pred"
    outputTensorName: "input"
    outputTensorName: "predicate"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "predicate"
      value: "pred"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Switch"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "unsorted_segment_max"
  inputFrameworkOpName: "UnsortedSegmentMax"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "segment_ids"
    outputTensorName: "input"
    outputTensorName: "idxSegments"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "idxSegments"
      value: "segment_ids"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "UnsortedSegmentMax"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputIntName: "numSegments"
    inputToOutput {
      key: "numSegments"
      value: "num_segments"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "UnsortedSegmentMax"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "segment_sum"
  inputFrameworkOpName: "SegmentSum"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "segment_ids"
    outputTensorName: "input"
    outputTensorName: "idxSegments"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "idxSegments"
      value: "segment_ids"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SegmentSum"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "resize_bilinear"
  inputFrameworkOpName: "ResizeBilinear"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    inputTensorName: "size"
    outputTensorName: "image"
    outputTensorName: "newImageSize"
    inputToOutput {
      key: "image"
      value: "images"
    }
    inputToOutput {
      key: "newImageSize"
      value: "size"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ResizeBilinear"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "align_corners"
    inputBooleanName: "half_pixel_centers"
    outputBooleanName: "alignCorners"
    outputBooleanName: "halfPixelCenters"
    inputToOutput {
      key: "alignCorners"
      value: "align_corners"
    }
    inputToOutput {
      key: "halfPixelCenters"
      value: "half_pixel_centers"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ResizeBilinear"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "softmax"
  inputFrameworkOpName: "Softmax"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "logits"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "logits"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Softmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dimension"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dimension"
        int64Value: 1
        argType: INT64
      }
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dimension"
        int64Value: 1
        argType: INT64
      }
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Softmax"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "split_list"
  inputFrameworkOpName: "TensorArraySplitV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "lengths"
    inputTensorName: "value"
    inputTensorName: "value"
    outputTensorName: "sizes"
    outputTensorName: "list"
    outputTensorName: "array"
    inputToOutput {
      key: "sizes"
      value: "lengths"
    }
    inputToOutput {
      key: "list"
      value: "value"
    }
    inputToOutput {
      key: "array"
      value: "value"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArraySplitV2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArraySplitV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "erf"
  inputFrameworkOpName: "Erf"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Erf"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Erf"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Erf"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "split_list"
  inputFrameworkOpName: "TensorArraySplitV3"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "lengths"
    inputTensorName: "value"
    inputTensorName: "value"
    outputTensorName: "sizes"
    outputTensorName: "list"
    outputTensorName: "array"
    inputToOutput {
      key: "sizes"
      value: "lengths"
    }
    inputToOutput {
      key: "list"
      value: "value"
    }
    inputToOutput {
      key: "array"
      value: "value"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArraySplitV3"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArraySplitV3"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "relu"
  inputFrameworkOpName: "Relu"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "features"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "features"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Relu"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "cutoff"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "cutoff"
        argType: DOUBLE
      }
    }
    inputFrameworkOpName: "Relu"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Relu"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "ceil"
  inputFrameworkOpName: "Ceil"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Ceil"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Ceil"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Ceil"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "l2_loss"
  inputFrameworkOpName: "L2Loss"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "t"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "t"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "L2Loss"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "L2Loss"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "switch"
  inputFrameworkOpName: "If"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "cond"
    outputTensorName: "input"
    outputTensorName: "predicate"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "predicate"
      value: "cond"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "If"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "cast"
  inputFrameworkOpName: "Cast"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Cast"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "DstT"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "DstT"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Cast"
  }
  rule {
    ruleName: "datatypetoint"
    functionName: "datatypetoint"
    outputIntName: "dst"
    inputDataTypeName: "DstT"
    inputToOutput {
      key: "dst"
      value: "DstT"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Cast"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "minimum"
  inputFrameworkOpName: "Minimum"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Minimum"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "non_max_suppression"
  inputFrameworkOpName: "NonMaxSuppression"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "boxes"
    inputTensorName: "scores"
    inputTensorName: "max_output_size"
    outputTensorName: "boxes"
    outputTensorName: "scales"
    outputTensorName: "maxOutputSize"
    inputToOutput {
      key: "boxes"
      value: "boxes"
    }
    inputToOutput {
      key: "scales"
      value: "scores"
    }
    inputToOutput {
      key: "maxOutputSize"
      value: "max_output_size"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "NonMaxSuppression"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "scoreThreshold"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "scoreThreshold"
        doubleValue: 0.5
        argType: DOUBLE
        argIndex: 1
      }
    }
    inputFrameworkOpName: "NonMaxSuppression"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputFloatName: "iou_threshold"
    inputToOutput {
      key: "overlayThreshold"
      value: "iou_threshold"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "NonMaxSuppression"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    inputToOutput {
      key: "maxOutputSize"
      value: "max_output_size"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "NonMaxSuppression"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "lstmBlock"
  inputFrameworkOpName: "BlockLSTM"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "seq_len_max"
    inputTensorName: "x"
    inputTensorName: "cs_prev"
    inputTensorName: "h_prev"
    inputTensorName: "w"
    inputTensorName: "wci"
    inputTensorName: "wcf"
    inputTensorName: "wco"
    inputTensorName: "b"
    outputTensorName: "maxTSLength"
    outputTensorName: "input"
    outputTensorName: "cLast"
    outputTensorName: "yLast"
    outputTensorName: "W"
    outputTensorName: "Wci"
    outputTensorName: "Wcf"
    outputTensorName: "Wco"
    outputTensorName: "b"
    inputToOutput {
      key: "maxTSLength"
      value: "seq_len_max"
    }
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "cLast"
      value: "cs_prev"
    }
    inputToOutput {
      key: "yLast"
      value: "h_prev"
    }
    inputToOutput {
      key: "W"
      value: "w"
    }
    inputToOutput {
      key: "Wci"
      value: "wci"
    }
    inputToOutput {
      key: "Wcf"
      value: "wcf"
    }
    inputToOutput {
      key: "Wco"
      value: "wco"
    }
    inputToOutput {
      key: "b"
      value: "b"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BlockLSTM"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputFloatName: "forget_bias"
    inputFloatName: "cell_clip"
    outputDoubleName: "forgetBias"
    outputDoubleName: "clippingCellValue"
    inputToOutput {
      key: "forgetBias"
      value: "forget_bias"
    }
    inputToOutput {
      key: "clippingCellValue"
      value: "cell_clip"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "BlockLSTM"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    outputIntName: "peephole"
    inputBooleanName: "use_peephole"
    inputToOutput {
      key: "peephole"
      value: "use_peephole"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "BlockLSTM"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dataFormat"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dataFormat"
        argType: INT64
      }
    }
    inputFrameworkOpName: "BlockLSTM"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "shape_of"
  inputFrameworkOpName: "Shape"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Shape"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Shape"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "out_type"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "out_type"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Shape"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "check_numerics"
  inputFrameworkOpName: "CheckNumerics"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "tensor"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "tensor"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "CheckNumerics"
  }
  rule {
    ruleName: "convertinputstringtondarray"
    functionName: "convertinputstringtondarray"
    inputStringAttrName: "message"
    inputToOutput {
      key: "message"
      value: "message"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "CheckNumerics"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "reduce_max"
  inputFrameworkOpName: "Max"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Max"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "keep_dims"
    outputBooleanName: "keepDims"
    inputToOutput {
      key: "keepDims"
      value: "keep_dims"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Max"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    inputToOutput {
      key: "dimensions"
      value: "reduction_indices"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Max"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "tensorarrayv3"
  inputFrameworkOpName: "TensorArrayV3"
  rule {
    ruleName: "datatypetoint"
    functionName: "datatypetoint"
    outputIntName: "dataType"
    inputDataTypeName: "dtype"
    inputToOutput {
      key: "dataType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArrayV3"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_max"
  inputFrameworkOpName: "ScatterMax"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "ref"
    inputTensorName: "indices"
    inputTensorName: "updates"
    outputTensorName: "input"
    outputTensorName: "indices"
    outputTensorName: "updates"
    inputToOutput {
      key: "input"
      value: "ref"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterMax"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "isnan"
  inputFrameworkOpName: "IsNan"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "IsNan"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "IsNan"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "gather_list"
  inputFrameworkOpName: "TensorArrayGather"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    inputTensorName: "flow_in"
    outputTensorName: "indices"
    outputTensorName: "list"
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayGather"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArrayGather"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "bincount"
  inputFrameworkOpName: "Bincount"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "weights"
    inputTensorName: "arr"
    outputTensorName: "weights"
    outputTensorName: "values"
    inputToOutput {
      key: "weights"
      value: "weights"
    }
    inputToOutput {
      key: "values"
      value: "arr"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Bincount"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "minLength"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "minLength"
        argType: INT64
      }
    }
    inputFrameworkOpName: "Bincount"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputIntName: "maxLength"
    inputToOutput {
      key: "maxLength"
      value: "size"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Bincount"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "outputType"
    inputToOutput {
      key: "outputType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Bincount"
  }
  indexOverrides {
    key: 1
    value: 2
  }
  indexOverrides {
    key: 2
    value: 1
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "space_to_batch_nd"
  inputFrameworkOpName: "SpaceToBatchND"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "block_shape"
    inputTensorName: "paddings"
    outputTensorName: "input"
    outputTensorName: "blockShape"
    outputTensorName: "padding"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "blockShape"
      value: "block_shape"
    }
    inputToOutput {
      key: "padding"
      value: "paddings"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SpaceToBatchND"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "blocks"
    inputToOutput {
      key: "blocks"
      value: "block_shape"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "SpaceToBatchND"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "SpaceToBatchND"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "reduce_prod"
  inputFrameworkOpName: "Prod"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Prod"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "keep_dims"
    outputBooleanName: "keepDims"
    inputToOutput {
      key: "keepDims"
      value: "keep_dims"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Prod"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    inputToOutput {
      key: "dimensions"
      value: "reduction_indices"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Prod"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "lgamma"
  inputFrameworkOpName: "Lgamma"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Lgamma"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matmul"
  inputFrameworkOpName: "BatchMatMulV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BatchMatMulV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "alpha"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "alpha"
        doubleValue: 1.0
        argType: DOUBLE
      }
    }
    inputFrameworkOpName: "BatchMatMulV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "beta"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "beta"
        doubleValue: 1.0
        argType: DOUBLE
        argIndex: 1
      }
    }
    inputFrameworkOpName: "BatchMatMulV2"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    outputIntName: "transX"
    outputIntName: "transY"
    inputBooleanName: "adj_x"
    inputBooleanName: "adj_y"
    inputToOutput {
      key: "transX"
      value: "adj_x"
    }
    inputToOutput {
      key: "transY"
      value: "adj_y"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "BatchMatMulV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "transZ"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "transZ"
        argType: INT64
        argIndex: 2
      }
    }
    inputFrameworkOpName: "BatchMatMulV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "unique_with_counts"
  inputFrameworkOpName: "UniqueWithCounts"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "UniqueWithCounts"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "randomuniform"
  inputFrameworkOpName: "RandomUniformInt"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "shape"
    inputTensorName: "minval"
    inputTensorName: "maxval"
    outputTensorName: "shape"
    outputTensorName: "min"
    outputTensorName: "max"
    inputToOutput {
      key: "shape"
      value: "shape"
    }
    inputToOutput {
      key: "min"
      value: "minval"
    }
    inputToOutput {
      key: "max"
      value: "maxval"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RandomUniformInt"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    inputToOutput {
      key: "min"
      value: "minval"
    }
    inputToOutput {
      key: "max"
      value: "maxval"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomUniformInt"
  }
  rule {
    ruleName: "datatypetoint"
    functionName: "datatypetoint"
    outputIntName: "dtype"
    inputDataTypeName: "Tout"
    inputToOutput {
      key: "dtype"
      value: "Tout"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomUniformInt"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "Tout"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "Tout"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomUniformInt"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "selu"
  inputFrameworkOpName: "Selu"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "features"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "features"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Selu"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Selu"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "argmin"
  inputFrameworkOpName: "ArgMin"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ArgMin"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "keepDims"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "keepDims"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ArgMin"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "resize_bicubic"
  inputFrameworkOpName: "ResizeBicubic"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    inputTensorName: "size"
    outputTensorName: "image"
    outputTensorName: "size"
    inputToOutput {
      key: "image"
      value: "images"
    }
    inputToOutput {
      key: "size"
      value: "size"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ResizeBicubic"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "align_corners"
    inputBooleanName: "half_pixel_centers"
    outputBooleanName: "alignCorners"
    outputBooleanName: "alignPixelCenters"
    inputToOutput {
      key: "alignCorners"
      value: "align_corners"
    }
    inputToOutput {
      key: "alignPixelCenters"
      value: "half_pixel_centers"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ResizeBicubic"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "atanh"
  inputFrameworkOpName: "Atanh"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Atanh"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Atanh"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Atanh"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "split_v"
  inputFrameworkOpName: "SplitV"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "value"
    inputTensorName: "size_splits"
    inputTensorName: "split_dim"
    outputTensorName: "input"
    outputTensorName: "sizes"
    outputTensorName: "_a"
    inputToOutput {
      key: "input"
      value: "value"
    }
    inputToOutput {
      key: "sizes"
      value: "size_splits"
    }
    inputToOutput {
      key: "_a"
      value: "split_dim"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SplitV"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "num_split"
    outputIntName: "numSplit"
    inputToOutput {
      key: "numSplit"
      value: "num_split"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "SplitV"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputIntName: "dimensions"
    inputToOutput {
      key: "dimensions"
      value: "split_dim"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "SplitV"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "dimensions"
    inputToOutput {
      key: "dimensions"
      value: "split_dim"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "SplitV"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "mirror_pad"
  inputFrameworkOpName: "MirrorPad"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "paddings"
    outputTensorName: "input"
    outputTensorName: "paddings"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "paddings"
      value: "paddings"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MirrorPad"
  }
  rule {
    ruleName: "stringnotequalsadapterrule"
    functionName: "stringnotequalsadapterrule"
    inputStringAttrName: "mode"
    outputIntName: "mode"
    inputFloatName: "mode"
    inputToOutput {
      key: "mode"
      value: "mode"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "mode"
      transformerArgs {
        name: "mode"
        stringValue: "REFLECT"
      }
    }
    inputFrameworkOpName: "MirrorPad"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "isSymmetric"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "isSymmetric"
        boolValue: true
        argType: BOOL
      }
    }
    inputFrameworkOpName: "MirrorPad"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "shapes_of"
  inputFrameworkOpName: "ShapeN"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ShapeN"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ShapeN"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "cos"
  inputFrameworkOpName: "Cos"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Cos"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Cos"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Cos"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "sqrt"
  inputFrameworkOpName: "Sqrt"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Sqrt"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Sqrt"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Sqrt"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "deconv2d_tf"
  inputFrameworkOpName: "Conv2DBackpropInput"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input_sizes"
    inputTensorName: "filter"
    outputTensorName: "gradIShape"
    outputTensorName: "weights"
    inputToOutput {
      key: "gradIShape"
      value: "input_sizes"
    }
    inputToOutput {
      key: "weights"
      value: "filter"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "wFormat"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "wFormat"
        argType: INT64
        argIndex: 10
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "stringnotequalsadapterrule"
    functionName: "stringnotequalsadapterrule"
    inputStringAttrName: "data_format"
    outputIntName: "isNCHW"
    inputFloatName: "data_format"
    inputToOutput {
      key: "isNCHW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNCHW"
      transformerArgs {
        name: "data_format"
        argIndex: 9
        stringValue: "NCHW"
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputIntName: "isSameMode"
    inputToOutput {
      key: "isSameMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isSameMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        argIndex: 8
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "sH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "sW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "dH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "dH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 6
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 6
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 6
        stringValue: "dilations"
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "conditionalfieldvalueintindex"
    functionName: "conditionalfieldvalueintindex"
    inputStringAttrName: "data_format"
    outputIntName: "dW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "dW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    transformerArgs {
      key: "dW"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 7
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 7
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 7
        stringValue: "dilations"
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "kH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "kH"
        int64Value: -1
        argType: INT64
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "kW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "kW"
        int64Value: -1
        argType: INT64
        argIndex: 1
      }
    }
    inputFrameworkOpName: "Conv2DBackpropInput"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "floordiv"
  inputFrameworkOpName: "FloorDiv"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "FloorDiv"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "FloorDiv"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FloorDiv"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "stack_list"
  inputFrameworkOpName: "TensorArrayConcatV3"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "flow_in"
    outputTensorName: "list"
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayConcatV3"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "stack_list"
  inputFrameworkOpName: "TensorArrayConcatV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "flow_in"
    outputTensorName: "list"
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayConcatV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "identity"
  inputFrameworkOpName: "CopyHost"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "CopyHost"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "CopyHost"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "neg"
  inputFrameworkOpName: "Neg"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Neg"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Neg"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Neg"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "top_k"
  inputFrameworkOpName: "TopKV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TopKV2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "sorted"
    outputBooleanName: "needSort"
    inputToOutput {
      key: "needSort"
      value: "sorted"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TopKV2"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputIntName: "k"
    inputToOutput {
      key: "k"
      value: "k"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TopKV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "resize_area"
  inputFrameworkOpName: "ResizeArea"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    inputTensorName: "size"
    outputTensorName: "image"
    outputTensorName: "size"
    inputToOutput {
      key: "image"
      value: "images"
    }
    inputToOutput {
      key: "size"
      value: "size"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ResizeArea"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "align_corners"
    outputBooleanName: "alignCorners"
    inputToOutput {
      key: "alignCorners"
      value: "align_corners"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ResizeArea"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "triangular_solve"
  inputFrameworkOpName: "MatrixTriangularSolve"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "matrix"
    inputTensorName: "rhs"
    outputTensorName: "a"
    outputTensorName: "b"
    inputToOutput {
      key: "a"
      value: "matrix"
    }
    inputToOutput {
      key: "b"
      value: "rhs"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MatrixTriangularSolve"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "adjoint"
    inputBooleanName: "lower"
    outputBooleanName: "useAdjoint"
    outputBooleanName: "isLower"
    inputToOutput {
      key: "useAdjoint"
      value: "adjoint"
    }
    inputToOutput {
      key: "isLower"
      value: "lower"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "MatrixTriangularSolve"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "softsign"
  inputFrameworkOpName: "Softsign"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "features"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "features"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Softsign"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Softsign"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "gather"
  inputFrameworkOpName: "GatherV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "params"
    inputTensorName: "indices"
    outputTensorName: "input"
    outputTensorName: "indices"
    inputToOutput {
      key: "input"
      value: "params"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "GatherV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "GatherV2"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "dimensions"
    inputToOutput {
      key: "dimensions"
      value: "axis"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "GatherV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "fake_quant_with_min_max_args"
  inputFrameworkOpName: "FakeQuantWithMinMaxArgs"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "inputs"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "inputs"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "FakeQuantWithMinMaxArgs"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "num_bits"
    outputIntName: "numBits"
    inputFloatName: "min"
    inputFloatName: "max"
    outputDoubleName: "min"
    outputDoubleName: "max"
    inputBooleanName: "narrow_range"
    outputBooleanName: "narrowRange"
    inputToOutput {
      key: "min"
      value: "min"
    }
    inputToOutput {
      key: "max"
      value: "max"
    }
    inputToOutput {
      key: "numBits"
      value: "num_bits"
    }
    inputToOutput {
      key: "narrowRange"
      value: "narrow_range"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FakeQuantWithMinMaxArgs"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "all"
  inputFrameworkOpName: "All"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "All"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "keep_dims"
    outputBooleanName: "keepDims"
    inputToOutput {
      key: "keepDims"
      value: "keep_dims"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "All"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "dimensions"
    inputToOutput {
      key: "dimensions"
      value: "reduction_indices"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "All"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "tan"
  inputFrameworkOpName: "Tan"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Tan"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Tan"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Tan"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "fill"
  inputFrameworkOpName: "Fill"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "dims"
    outputTensorName: "shapeArray"
    inputToOutput {
      key: "shapeArray"
      value: "dims"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Fill"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputDoubleName: "value"
    inputToOutput {
      key: "value"
      value: "value"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Fill"
  }
  rule {
    ruleName: "datatypetoint"
    functionName: "datatypetoint"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Fill"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Fill"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_add"
  inputFrameworkOpName: "ScatterAdd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "ref"
    inputTensorName: "indices"
    inputTensorName: "updates"
    outputTensorName: "input"
    outputTensorName: "indices"
    outputTensorName: "updates"
    inputToOutput {
      key: "input"
      value: "ref"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterAdd"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "lock"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "lock"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ScatterAdd"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "checkIndices"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "checkIndices"
        argType: BOOL
        argIndex: 1
      }
    }
    inputFrameworkOpName: "ScatterAdd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "max_pool_with_argmax"
  inputFrameworkOpName: "MaxPoolWithArgmax"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "kH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "kH"
        int64Value: 1
        argType: INT64
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "kW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "kW"
        int64Value: 1
        argType: INT64
        argIndex: 1
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "sH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "sH"
        int64Value: 1
        argType: INT64
        argIndex: 2
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "sW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "sW"
        int64Value: 1
        argType: INT64
        argIndex: 3
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        int64Value: 1
        argType: INT64
        argIndex: 4
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pW"
        int64Value: 1
        argType: INT64
        argIndex: 5
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dH"
        int64Value: 1
        argType: INT64
        argIndex: 6
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dW"
        int64Value: 1
        argType: INT64
        argIndex: 7
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "extraParam0"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "extraParam0"
        argType: INT64
        argIndex: 9
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "isNHWC"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "isNHWC"
        int64Value: 1
        argType: INT64
        argIndex: 10
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "sameMode"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "sameMode"
        int64Value: 8
        argType: INT64
        argIndex: 8
      }
    }
    inputFrameworkOpName: "MaxPoolWithArgmax"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matrix_diag_part"
  inputFrameworkOpName: "MatrixDiagPart"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MatrixDiagPart"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "MatrixDiagPart"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "fused_batch_norm"
  inputFrameworkOpName: "FusedBatchNormV3"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "scale"
    inputTensorName: "offset"
    inputTensorName: "mean"
    inputTensorName: "variance"
    outputTensorName: "input"
    outputTensorName: "scale"
    outputTensorName: "offset"
    outputTensorName: "mean"
    outputTensorName: "variance"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "scale"
      value: "scale"
    }
    inputToOutput {
      key: "offset"
      value: "offset"
    }
    inputToOutput {
      key: "mean"
      value: "mean"
    }
    inputToOutput {
      key: "variance"
      value: "variance"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "FusedBatchNormV3"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputFloatName: "epsilon"
    outputDoubleName: "epsilon"
    inputToOutput {
      key: "epsilon"
      value: "epsilon"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FusedBatchNormV3"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    outputIntName: "isTraining"
    inputBooleanName: "is_training"
    inputToOutput {
      key: "isTraining"
      value: "is_training"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FusedBatchNormV3"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "data_format"
    inputStringAttrName: "data_format"
    outputIntName: "dataFormat"
    inputToOutput {
      key: "dataFormat"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dataFormat"
      transformerArgs {
        name: "data_format"
        argType: STRING
        stringValue: "NCHW"
      }
    }
    inputFrameworkOpName: "FusedBatchNormV3"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "gather_list"
  inputFrameworkOpName: "TensorArrayGatherV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    inputTensorName: "flow_in"
    outputTensorName: "indices"
    outputTensorName: "list"
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayGatherV2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArrayGatherV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "noop"
  inputFrameworkOpName: "NoOp"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    ruleType: "tensor"
    inputFrameworkOpName: "NoOp"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "gather_list"
  inputFrameworkOpName: "TensorArrayGatherV3"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    inputTensorName: "flow_in"
    outputTensorName: "indices"
    outputTensorName: "list"
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "list"
      value: "flow_in"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorArrayGatherV3"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TensorArrayGatherV3"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "lrn"
  inputFrameworkOpName: "LRN"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LRN"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "depth_radius"
    outputIntName: "depth"
    inputFloatName: "alpha"
    inputFloatName: "bias"
    inputFloatName: "beta"
    outputDoubleName: "alpha"
    outputDoubleName: "bias"
    outputDoubleName: "beta"
    inputToOutput {
      key: "depth"
      value: "depth_radius"
    }
    inputToOutput {
      key: "alpha"
      value: "alpha"
    }
    inputToOutput {
      key: "bias"
      value: "bias"
    }
    inputToOutput {
      key: "beta"
      value: "beta"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "LRN"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "LRN"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "betainc"
  inputFrameworkOpName: "Betainc"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "a"
    inputTensorName: "b"
    inputTensorName: "x"
    outputTensorName: "a"
    outputTensorName: "b"
    outputTensorName: "input"
    inputToOutput {
      key: "a"
      value: "a"
    }
    inputToOutput {
      key: "b"
      value: "b"
    }
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Betainc"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "diag_part"
  inputFrameworkOpName: "DiagPart"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "DiagPart"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "DiagPart"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "concat"
  inputFrameworkOpName: "Concat"
  rule {
    ruleName: "multiinputindex"
    functionName: "multiinputindex"
    inputTensorName: "values"
    inputTensorName: "concat_dim"
    outputTensorName: "input"
    outputTensorName: "concatDimension"
    inputToOutput {
      key: "input"
      value: "values"
    }
    inputToOutput {
      key: "concatDimension"
      value: "concat_dim"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Concat"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    inputToOutput {
      key: "concatDimension"
      value: "concat_dim"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Concat"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "isDynamicAxis"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "isDynamicAxis"
        boolValue: true
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Concat"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Concat"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "segment_prod"
  inputFrameworkOpName: "SegmentProd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "segment_ids"
    outputTensorName: "input"
    outputTensorName: "idxSegments"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "idxSegments"
      value: "segment_ids"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SegmentProd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "top_k"
  inputFrameworkOpName: "TopK"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TopK"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "k"
    outputIntName: "k"
    inputBooleanName: "sorted"
    outputBooleanName: "needSort"
    inputToOutput {
      key: "needSort"
      value: "sorted"
    }
    inputToOutput {
      key: "k"
      value: "k"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TopK"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "fake_quant_with_min_max_vars_per_channel"
  inputFrameworkOpName: "FakeQuantWithMinMaxVarsPerChannel"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "inputs"
    inputTensorName: "min"
    inputTensorName: "max"
    outputTensorName: "input"
    outputTensorName: "min"
    outputTensorName: "max"
    inputToOutput {
      key: "input"
      value: "inputs"
    }
    inputToOutput {
      key: "min"
      value: "min"
    }
    inputToOutput {
      key: "max"
      value: "max"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "FakeQuantWithMinMaxVarsPerChannel"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "num_bits"
    outputIntName: "numBits"
    inputBooleanName: "narrow_range"
    outputBooleanName: "narrowed"
    inputToOutput {
      key: "numBits"
      value: "num_bits"
    }
    inputToOutput {
      key: "narrowed"
      value: "narrow_range"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FakeQuantWithMinMaxVarsPerChannel"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "maximum"
  inputFrameworkOpName: "Maximum"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Maximum"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Maximum"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Maximum"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "mergeadd"
  inputFrameworkOpName: "AccumulateNV2"
  rule {
    ruleName: "multiinputindex"
    functionName: "multiinputindex"
    inputTensorName: "inputs"
    outputTensorName: "inArrs"
    inputToOutput {
      key: "inArrs"
      value: "inputs"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "AccumulateNV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "AccumulateNV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "asinh"
  inputFrameworkOpName: "Asinh"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Asinh"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Asinh"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Asinh"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "fused_batch_norm"
  inputFrameworkOpName: "FusedBatchNormV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "scale"
    inputTensorName: "offset"
    inputTensorName: "mean"
    inputTensorName: "variance"
    outputTensorName: "input"
    outputTensorName: "scale"
    outputTensorName: "offset"
    outputTensorName: "mean"
    outputTensorName: "variance"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "scale"
      value: "scale"
    }
    inputToOutput {
      key: "offset"
      value: "offset"
    }
    inputToOutput {
      key: "mean"
      value: "mean"
    }
    inputToOutput {
      key: "variance"
      value: "variance"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "FusedBatchNormV2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputFloatName: "epsilon"
    outputDoubleName: "epsilon"
    inputToOutput {
      key: "epsilon"
      value: "epsilon"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FusedBatchNormV2"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    outputIntName: "isTraining"
    inputBooleanName: "is_training"
    inputToOutput {
      key: "isTraining"
      value: "is_training"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FusedBatchNormV2"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "data_format"
    inputStringAttrName: "data_format"
    outputIntName: "dataFormat"
    inputToOutput {
      key: "dataFormat"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "dataFormat"
      transformerArgs {
        name: "data_format"
        argType: STRING
        stringValue: "NCHW"
      }
    }
    inputFrameworkOpName: "FusedBatchNormV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "Reciprocal"
  inputFrameworkOpName: "Reciprocal"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Reciprocal"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "in_top_k"
  inputFrameworkOpName: "InTopKV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "targets"
    inputTensorName: "predictions"
    outputTensorName: "target"
    outputTensorName: "predictions"
    inputToOutput {
      key: "target"
      value: "targets"
    }
    inputToOutput {
      key: "predictions"
      value: "predictions"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "InTopKV2"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "k"
    inputToOutput {
      key: "k"
      value: "k"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "InTopKV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "sorted"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "sorted"
        boolValue: true
        argType: BOOL
      }
    }
    inputFrameworkOpName: "InTopKV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "less"
  inputFrameworkOpName: "Less"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Less"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Less"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Less"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "nth_element"
  inputFrameworkOpName: "NthElement"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "n"
    inputTensorName: "input"
    outputTensorName: "n"
    outputTensorName: "input"
    inputToOutput {
      key: "n"
      value: "n"
    }
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "NthElement"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    inputBooleanName: "reverse"
    outputBooleanName: "reverse"
    inputToOutput {
      key: "reverse"
      value: "reverse"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "NthElement"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matmul"
  inputFrameworkOpName: "BatchMatMul"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BatchMatMul"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "alpha"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "alpha"
        doubleValue: 1.0
        argType: DOUBLE
      }
    }
    inputFrameworkOpName: "BatchMatMul"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "beta"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "beta"
        doubleValue: 1.0
        argType: DOUBLE
        argIndex: 1
      }
    }
    inputFrameworkOpName: "BatchMatMul"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    outputIntName: "transX"
    outputIntName: "transY"
    inputBooleanName: "adj_x"
    inputBooleanName: "adj_y"
    inputToOutput {
      key: "transX"
      value: "adj_x"
    }
    inputToOutput {
      key: "transY"
      value: "adj_y"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "BatchMatMul"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "transZ"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "transZ"
        argType: INT64
        argIndex: 2
      }
    }
    inputFrameworkOpName: "BatchMatMul"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "multiply"
  inputFrameworkOpName: "Mul"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Mul"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Mul"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Mul"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "identity_n"
  inputFrameworkOpName: "IdentityN"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "IdentityN"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "lu"
  inputFrameworkOpName: "Lu"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Lu"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "diag"
  inputFrameworkOpName: "Diag"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "diagonal"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "diagonal"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Diag"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Diag"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "range"
  inputFrameworkOpName: "Range"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "start"
    inputTensorName: "limit"
    inputTensorName: "delta"
    outputTensorName: "from"
    outputTensorName: "to"
    outputTensorName: "step"
    inputToOutput {
      key: "from"
      value: "start"
    }
    inputToOutput {
      key: "to"
      value: "limit"
    }
    inputToOutput {
      key: "step"
      value: "delta"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Range"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    inputToOutput {
      key: "from"
      value: "start"
    }
    inputToOutput {
      key: "to"
      value: "limit"
    }
    inputToOutput {
      key: "step"
      value: "delta"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Range"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "Tidx"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "Tidx"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Range"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "histogram_fixed_width"
  inputFrameworkOpName: "HistogramFixedWidth"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "values"
    inputTensorName: "value_range"
    inputTensorName: "nbins"
    outputTensorName: "input"
    outputTensorName: "range"
    outputTensorName: "numBins"
    inputToOutput {
      key: "input"
      value: "values"
    }
    inputToOutput {
      key: "range"
      value: "value_range"
    }
    inputToOutput {
      key: "numBins"
      value: "nbins"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "HistogramFixedWidth"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "nbins"
    inputToOutput {
      key: "nbins"
      value: "nbins"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "HistogramFixedWidth"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "divide_no_nan"
  inputFrameworkOpName: "DivNoNan"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "DivNoNan"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "broadcast_dynamic_shape"
  inputFrameworkOpName: "BroadcastArgs"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "s0"
    inputTensorName: "s1"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "s0"
    }
    inputToOutput {
      key: "y"
      value: "s1"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BroadcastArgs"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_div"
  inputFrameworkOpName: "ScatterDiv"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "ref"
    inputTensorName: "indices"
    inputTensorName: "updates"
    outputTensorName: "input"
    outputTensorName: "indices"
    outputTensorName: "updates"
    inputToOutput {
      key: "input"
      value: "ref"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterDiv"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "reshape"
  inputFrameworkOpName: "Reshape"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "tensor"
    inputTensorName: "shape"
    outputTensorName: "input"
    outputTensorName: "shape"
    inputToOutput {
      key: "input"
      value: "tensor"
    }
    inputToOutput {
      key: "shape"
      value: "shape"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Reshape"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "copy"
  inputFrameworkOpName: "Copy"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Copy"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Copy"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "slice"
  inputFrameworkOpName: "Slice"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "begin"
    inputTensorName: "size"
    outputTensorName: "input"
    outputTensorName: "b"
    outputTensorName: "e"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "b"
      value: "begin"
    }
    inputToOutput {
      key: "e"
      value: "size"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Slice"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "size"
    inputToOutput {
      key: "size"
      value: "size"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Slice"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "leakyrelu"
  inputFrameworkOpName: "LeakyRelu"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "features"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "features"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LeakyRelu"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputFloatName: "alpha"
    outputDoubleName: "alpha"
    inputToOutput {
      key: "alpha"
      value: "alpha"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "LeakyRelu"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matrix_inverse"
  inputFrameworkOpName: "MatrixInverse"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MatrixInverse"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        boolValue: true
        argType: BOOL
      }
    }
    inputFrameworkOpName: "BatchMatrixInverse"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "tf_atan2"
  inputFrameworkOpName: "Atan2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Atan2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Atan2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Atan2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "batch_to_space"
  inputFrameworkOpName: "BatchToSpace"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "crops"
    outputTensorName: "input"
    outputTensorName: "crop"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "crop"
      value: "crops"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BatchToSpace"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "block_size"
    outputIntName: "blockSize"
    inputToOutput {
      key: "blockSize"
      value: "block_size"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "BatchToSpace"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "acos"
  inputFrameworkOpName: "Acos"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Acos"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Acos"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Acos"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "gather_nd"
  inputFrameworkOpName: "GatherNd"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "params"
    inputTensorName: "indices"
    outputTensorName: "input"
    outputTensorName: "indices"
    inputToOutput {
      key: "input"
      value: "params"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "GatherNd"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    ruleType: "attribute"
    inputFrameworkOpName: "GatherNd"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "checkIndices"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "checkIndices"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "GatherNd"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "maxpool2d"
  inputFrameworkOpName: "MaxPoolV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "extraParam0"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "extraParam0"
        argType: INT64
        argIndex: 9
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pH"
        argType: INT64
        argIndex: 4
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "pW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "pW"
        argType: INT64
        argIndex: 5
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dW"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dW"
        int64Value: 1
        argType: INT64
        argIndex: 6
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dH"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dH"
        int64Value: 1
        argType: INT64
        argIndex: 7
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "stringnotequalsadapterrule"
    functionName: "stringnotequalsadapterrule"
    inputStringAttrName: "data_format"
    outputIntName: "isNCHW"
    inputFloatName: "data_format"
    inputToOutput {
      key: "isNCHW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isNCHW"
      transformerArgs {
        name: "data_format"
        argIndex: 10
        stringValue: "NCHW"
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputIntName: "isSameMode"
    inputToOutput {
      key: "isSameMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isSameMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        argIndex: 8
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "conditionalfieldvalueintindexndarray"
    functionName: "conditionalfieldvalueintindexndarray"
    inputStringAttrName: "data_format"
    outputIntName: "sH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        argIndex: 2
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        argIndex: 2
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        argIndex: 2
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sH"
      transformerArgs {
        name: "targetValue"
        argIndex: 2
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
        argIndex: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
        argIndex: 2
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 2
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "conditionalfieldvalueintindexndarray"
    functionName: "conditionalfieldvalueintindexndarray"
    inputStringAttrName: "data_format"
    outputIntName: "sW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "sW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        argIndex: 3
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        argIndex: 3
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        argIndex: 3
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    transformerArgs {
      key: "sW"
      transformerArgs {
        name: "targetValue"
        argIndex: 3
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 3
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 3
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 3
        stringValue: "strides"
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "conditionalfieldvalueintindexndarray"
    functionName: "conditionalfieldvalueintindexndarray"
    inputStringAttrName: "data_format"
    outputIntName: "kH"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "kH"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kH"
      transformerArgs {
        name: "targetValue"
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 2
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        stringValue: "ksize"
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
  rule {
    ruleName: "conditionalfieldvalueintindexndarray"
    functionName: "conditionalfieldvalueintindexndarray"
    inputStringAttrName: "data_format"
    outputIntName: "kW"
    inputFloatName: "targetValue"
    inputFloatName: "trueIndex"
    inputFloatName: "falseIndex"
    inputFloatName: "attributeNameOfListAttribute"
    inputToOutput {
      key: "kW"
      value: "data_format"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        argIndex: 1
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        argIndex: 1
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        argIndex: 1
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    transformerArgs {
      key: "kW"
      transformerArgs {
        name: "targetValue"
        argIndex: 1
        stringValue: "NCHW"
      }
      transformerArgs {
        name: "trueIndex"
        int64Value: 3
        argIndex: 1
      }
      transformerArgs {
        name: "falseIndex"
        int64Value: 2
        argIndex: 1
      }
      transformerArgs {
        name: "attributeNameOfListAttribute"
        argIndex: 1
        stringValue: "ksize"
      }
    }
    inputFrameworkOpName: "MaxPoolV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "cholesky"
  inputFrameworkOpName: "Cholesky"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Cholesky"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "random_crop"
  inputFrameworkOpName: "RandomCrop"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "image"
    inputTensorName: "size"
    outputTensorName: "input"
    outputTensorName: "shape"
    inputToOutput {
      key: "input"
      value: "image"
    }
    inputToOutput {
      key: "shape"
      value: "size"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RandomCrop"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "seed"
    outputIntName: "seed"
    inputToOutput {
      key: "seed"
      value: "seed"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomCrop"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "batch_to_space_nd"
  inputFrameworkOpName: "BatchToSpaceND"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "crops"
    inputTensorName: "block_shape"
    outputTensorName: "input"
    outputTensorName: "crop"
    outputTensorName: "blockShape"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "crop"
      value: "crops"
    }
    inputToOutput {
      key: "blockShape"
      value: "block_shape"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BatchToSpaceND"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "blocks"
    inputToOutput {
      key: "blocks"
      value: "block_shape"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "BatchToSpaceND"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "BatchToSpaceND"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "reduce_mean"
  inputFrameworkOpName: "Mean"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Mean"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "keep_dims"
    outputBooleanName: "keepDims"
    inputToOutput {
      key: "keepDims"
      value: "keep_dims"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Mean"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    inputToOutput {
      key: "dimensions"
      value: "reduction_indices"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Mean"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "cosh"
  inputFrameworkOpName: "Cosh"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Cosh"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Cosh"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Cosh"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "identity"
  inputFrameworkOpName: "Variable"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    ruleType: "tensor"
    inputFrameworkOpName: "Variable"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Variable"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Variable"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "log_softmax"
  inputFrameworkOpName: "LogSoftmax"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "logits"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "logits"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LogSoftmax"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    ruleType: "attribute"
    inputFrameworkOpName: "LogSoftmax"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "cross"
  inputFrameworkOpName: "Cross"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "a"
    inputTensorName: "b"
    outputTensorName: "a"
    outputTensorName: "b"
    inputToOutput {
      key: "a"
      value: "a"
    }
    inputToOutput {
      key: "b"
      value: "b"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Cross"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "matrix_set_diag"
  inputFrameworkOpName: "BatchMatrixSetDiag"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    inputTensorName: "diagonal"
    outputTensorName: "input"
    outputTensorName: "diagonal"
    inputToOutput {
      key: "input"
      value: "input"
    }
    inputToOutput {
      key: "diagonal"
      value: "diagonal"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BatchMatrixSetDiag"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "BatchMatrixSetDiag"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "non_max_suppression_overlaps"
  inputFrameworkOpName: "NonMaxSuppressionWithOverlaps"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "scores"
    inputTensorName: "overlaps"
    outputTensorName: "scales"
    outputTensorName: "boxes"
    inputToOutput {
      key: "scales"
      value: "scores"
    }
    inputToOutput {
      key: "boxes"
      value: "overlaps"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "NonMaxSuppressionWithOverlaps"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputIntName: "maxOutputSize"
    outputDoubleName: "overlapThreshold"
    outputDoubleName: "scoreThreshold"
    inputToOutput {
      key: "maxOutputSize"
      value: "max_output_size"
    }
    inputToOutput {
      key: "overlapThreshold"
      value: "overlap_threshold"
    }
    inputToOutput {
      key: "scoreThreshold"
      value: "score_threshold"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "NonMaxSuppressionWithOverlaps"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "concat"
  inputFrameworkOpName: "ConcatV2"
  rule {
    ruleName: "multiinputindex"
    functionName: "multiinputindex"
    inputTensorName: "values"
    inputTensorName: "axis"
    outputTensorName: "input"
    outputTensorName: "concatDimension"
    inputToOutput {
      key: "input"
      value: "values"
    }
    inputToOutput {
      key: "concatDimension"
      value: "axis"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ConcatV2"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    inputToOutput {
      key: "concatDimension"
      value: "axis"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ConcatV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "isDynamicAxis"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "isDynamicAxis"
        boolValue: true
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ConcatV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "truncatediv"
  inputFrameworkOpName: "TruncateDiv"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TruncateDiv"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "TruncateDiv"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "TruncateDiv"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "any"
  inputFrameworkOpName: "Any"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Any"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputBooleanName: "keep_dims"
    outputBooleanName: "keepDims"
    inputToOutput {
      key: "keepDims"
      value: "keep_dims"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Any"
  }
  rule {
    ruleName: "ndarraytointattributevalue"
    functionName: "ndarraytointattributevalue"
    outputIntName: "dimensions"
    inputToOutput {
      key: "dimensions"
      value: "reduction_indices"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Any"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "boolean_or"
  inputFrameworkOpName: "LogicalOr"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LogicalOr"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "Reciprocal"
  inputFrameworkOpName: "Inv"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Inv"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "boolean_not"
  inputFrameworkOpName: "LogicalNot"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "LogicalNot"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "igammac"
  inputFrameworkOpName: "Igammac"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "a"
    inputTensorName: "x"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "a"
    }
    inputToOutput {
      key: "y"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Igammac"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "extract_image_patches"
  inputFrameworkOpName: "ExtractImagePatches"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "images"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ExtractImagePatches"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "ksizeRows"
    inputToOutput {
      key: "ksizeRows"
      value: "ksizes"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "ksizeRows"
      transformerArgs {
        name: "index"
        int64Value: 1
        argType: INT64
      }
    }
    inputFrameworkOpName: "ExtractImagePatches"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "ksizeCols"
    inputToOutput {
      key: "ksizeCols"
      value: "ksizes"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "ksizeCols"
      transformerArgs {
        name: "index"
        int64Value: 2
        argType: INT64
        argIndex: 1
      }
    }
    inputFrameworkOpName: "ExtractImagePatches"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "kstrideRows"
    inputToOutput {
      key: "kstrideRows"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kstrideRows"
      transformerArgs {
        name: "index"
        int64Value: 1
        argType: INT64
        argIndex: 2
      }
    }
    inputFrameworkOpName: "ExtractImagePatches"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "kstrideCols"
    inputToOutput {
      key: "kstrideCols"
      value: "strides"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "kstrideCols"
      transformerArgs {
        name: "index"
        int64Value: 2
        argType: INT64
        argIndex: 3
      }
    }
    inputFrameworkOpName: "ExtractImagePatches"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "krateRows"
    inputToOutput {
      key: "krateRows"
      value: "rates"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "krateRows"
      transformerArgs {
        name: "index"
        int64Value: 1
        argType: INT64
        argIndex: 4
      }
    }
    inputFrameworkOpName: "ExtractImagePatches"
  }
  rule {
    ruleName: "listattributevaluelookuptoindex"
    functionName: "listattributevaluelookuptoindex"
    inputIntName: "index"
    outputIntName: "krateCols"
    inputToOutput {
      key: "krateCols"
      value: "rates"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "krateCols"
      transformerArgs {
        name: "index"
        int64Value: 2
        argType: INT64
        argIndex: 5
      }
    }
    inputFrameworkOpName: "ExtractImagePatches"
  }
  rule {
    ruleName: "stringequals"
    functionName: "stringequals"
    inputStringAttrName: "padding"
    inputStringAttrName: "padding"
    outputBooleanName: "isSameMode"
    inputToOutput {
      key: "isSameMode"
      value: "padding"
    }
    ruleType: "attribute"
    transformerArgs {
      key: "isSameMode"
      transformerArgs {
        name: "padding"
        argType: STRING
        stringValue: "SAME"
      }
    }
    inputFrameworkOpName: "ExtractImagePatches"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ExtractImagePatches"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "fake_quant_with_min_max_vars"
  inputFrameworkOpName: "FakeQuantWithMinMaxVars"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "inputs"
    inputTensorName: "min"
    inputTensorName: "max"
    outputTensorName: "input"
    outputTensorName: "min"
    outputTensorName: "max"
    inputToOutput {
      key: "input"
      value: "inputs"
    }
    inputToOutput {
      key: "min"
      value: "min"
    }
    inputToOutput {
      key: "max"
      value: "max"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "FakeQuantWithMinMaxVars"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "num_bits"
    outputIntName: "numBits"
    inputBooleanName: "narrow_range"
    outputBooleanName: "narrowed"
    inputToOutput {
      key: "numBits"
      value: "num_bits"
    }
    inputToOutput {
      key: "narrowed"
      value: "narrow_range"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "FakeQuantWithMinMaxVars"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "round"
  inputFrameworkOpName: "Round"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Round"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Round"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Round"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "dynamic_stitch"
  inputFrameworkOpName: "ParallelDynamicStitch"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "indices"
    outputTensorName: "index"
    outputTensorName: "input"
    inputToOutput {
      key: "index"
      value: "data"
    }
    inputToOutput {
      key: "input"
      value: "indices"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ParallelDynamicStitch"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputIntName: "N"
    outputIntName: "numPartitions"
    inputToOutput {
      key: "numPartitions"
      value: "N"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ParallelDynamicStitch"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "sigmoid"
  inputFrameworkOpName: "Sigmoid"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Sigmoid"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Sigmoid"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Sigmoid"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "lstmBlock"
  inputFrameworkOpName: "BlockLSTMV2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "seq_len_max"
    inputTensorName: "x"
    inputTensorName: "cs_prev"
    inputTensorName: "h_prev"
    inputTensorName: "w"
    inputTensorName: "wci"
    inputTensorName: "wcf"
    inputTensorName: "wco"
    inputTensorName: "b"
    outputTensorName: "maxTSLength"
    outputTensorName: "input"
    outputTensorName: "cLast"
    outputTensorName: "yLast"
    outputTensorName: "W"
    outputTensorName: "Wci"
    outputTensorName: "Wcf"
    outputTensorName: "Wco"
    outputTensorName: "b"
    inputToOutput {
      key: "maxTSLength"
      value: "seq_len_max"
    }
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "cLast"
      value: "cs_prev"
    }
    inputToOutput {
      key: "yLast"
      value: "h_prev"
    }
    inputToOutput {
      key: "W"
      value: "w"
    }
    inputToOutput {
      key: "Wci"
      value: "wci"
    }
    inputToOutput {
      key: "Wcf"
      value: "wcf"
    }
    inputToOutput {
      key: "Wco"
      value: "wco"
    }
    inputToOutput {
      key: "b"
      value: "b"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "BlockLSTMV2"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputFloatName: "cell_clip"
    outputDoubleName: "clippingCellValue"
    inputToOutput {
      key: "clippingCellValue"
      value: "cell_clip"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "BlockLSTMV2"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    outputIntName: "peephole"
    inputBooleanName: "use_peephole"
    inputToOutput {
      key: "peephole"
      value: "use_peephole"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "BlockLSTMV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputFloatName: "forgetBias"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "forgetBias"
        doubleValue: 3.0
        argType: DOUBLE
      }
    }
    inputFrameworkOpName: "BlockLSTMV2"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputIntName: "dataFormat"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "dataFormat"
        argType: INT64
      }
    }
    inputFrameworkOpName: "BlockLSTMV2"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "atan"
  inputFrameworkOpName: "Atan"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Atan"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Atan"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Atan"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "ClipByValue"
  inputFrameworkOpName: "ClipByValue"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "t"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "t"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ClipByValue"
  }
  rule {
    ruleName: "ndarrayinputtonumericalattribute"
    functionName: "ndarrayinputtonumericalattribute"
    outputDoubleName: "clipValueMin"
    outputDoubleName: "clipValueMax"
    inputToOutput {
      key: "clipValueMin"
      value: "clip_value_min"
    }
    inputToOutput {
      key: "clipValueMax"
      value: "clip_value_max"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "ClipByValue"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "ClipByValue"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "segment_mean"
  inputFrameworkOpName: "SegmentMean"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "data"
    inputTensorName: "segment_ids"
    outputTensorName: "input"
    outputTensorName: "idxSegments"
    inputToOutput {
      key: "input"
      value: "data"
    }
    inputToOutput {
      key: "idxSegments"
      value: "segment_ids"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "SegmentMean"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "floor"
  inputFrameworkOpName: "Floor"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Floor"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Floor"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Floor"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_upd"
  inputFrameworkOpName: "ScatterUpdate"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "ref"
    inputTensorName: "updates"
    inputTensorName: "indices"
    outputTensorName: "input"
    outputTensorName: "updates"
    outputTensorName: "indices"
    inputToOutput {
      key: "input"
      value: "ref"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ScatterUpdate"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "identity"
  inputFrameworkOpName: "DeepCopy"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "DeepCopy"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "DeepCopy"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "hsv_to_rgb"
  inputFrameworkOpName: "HSVToRGB"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "images"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "HSVToRGB"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "listdiff"
  inputFrameworkOpName: "ListDiff"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "values"
    outputTensorName: "keep"
    inputToOutput {
      key: "values"
      value: "x"
    }
    inputToOutput {
      key: "keep"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "ListDiff"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "While"
  inputFrameworkOpName: "While"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "input"
    outputTensorName: "condition"
    inputToOutput {
      key: "condition"
      value: "input"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "While"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "isConstant"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "isConstant"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "While"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_upd"
  inputFrameworkOpName: "TensorScatterUpdate"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "tensor"
    inputTensorName: "updates"
    inputTensorName: "indices"
    outputTensorName: "input"
    outputTensorName: "updates"
    outputTensorName: "indices"
    inputToOutput {
      key: "input"
      value: "tensor"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorScatterUpdate"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "scatter_sub"
  inputFrameworkOpName: "TensorScatterSub"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "indices"
    inputTensorName: "updates"
    inputTensorName: "tensor"
    outputTensorName: "indices"
    outputTensorName: "updates"
    outputTensorName: "input"
    inputToOutput {
      key: "indices"
      value: "indices"
    }
    inputToOutput {
      key: "updates"
      value: "updates"
    }
    inputToOutput {
      key: "input"
      value: "tensor"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "TensorScatterSub"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "lock"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "lock"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "TensorScatterSub"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "checkIndices"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "checkIndices"
        argType: BOOL
        argIndex: 1
      }
    }
    inputFrameworkOpName: "TensorScatterSub"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "cumprod"
  inputFrameworkOpName: "Cumprod"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "axis"
    outputTensorName: "input"
    outputTensorName: "dimensions"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "dimensions"
      value: "axis"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Cumprod"
  }
  rule {
    ruleName: "invertbooleannumber"
    functionName: "invertbooleannumber"
    inputBooleanName: "exclusive"
    inputBooleanName: "reverse"
    outputBooleanName: "exclusive"
    outputBooleanName: "reverse"
    inputToOutput {
      key: "exclusive"
      value: "exclusive"
    }
    inputToOutput {
      key: "reverse"
      value: "reverse"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Cumprod"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "mergesum"
  inputFrameworkOpName: "AddN"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "inputs"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "inputs"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "AddN"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "random_normal"
  inputFrameworkOpName: "RandomStandardNormal"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "shape"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "shape"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "RandomStandardNormal"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "dtype"
    outputDataTypeName: "dtype"
    inputToOutput {
      key: "dtype"
      value: "dtype"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "RandomStandardNormal"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "sign"
  inputFrameworkOpName: "Sign"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Sign"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Sign"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Sign"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "greater"
  inputFrameworkOpName: "Greater"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    inputTensorName: "y"
    outputTensorName: "input"
    outputTensorName: "y"
    inputToOutput {
      key: "input"
      value: "x"
    }
    inputToOutput {
      key: "y"
      value: "y"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Greater"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Greater"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Greater"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "exp"
  inputFrameworkOpName: "Exp"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "x"
    outputTensorName: "input"
    inputToOutput {
      key: "input"
      value: "x"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "Exp"
  }
  rule {
    ruleName: "valuemapping"
    functionName: "valuemapping"
    inputDataTypeName: "T"
    outputDataTypeName: "dataType"
    inputToOutput {
      key: "dataType"
      value: "T"
    }
    ruleType: "attribute"
    inputFrameworkOpName: "Exp"
  }
  rule {
    ruleName: "argdescriptorconstant"
    functionName: "argdescriptorconstant"
    inputBooleanName: "inPlace"
    ruleType: "attribute"
    transformerArgs {
      key: "value"
      transformerArgs {
        name: "inPlace"
        argType: BOOL
      }
    }
    inputFrameworkOpName: "Exp"
  }
}
mappings {
  frameworkName: "tensorflow"
  opName: "adjust_contrast_v2"
  inputFrameworkOpName: "AdjustContrastv2"
  rule {
    ruleName: "ndarraymapping"
    functionName: "ndarraymapping"
    inputTensorName: "images"
    inputTensorName: "contrast_factor"
    outputTensorName: "input"
    outputTensorName: "factor"
    inputToOutput {
      key: "input"
      value: "images"
    }
    inputToOutput {
      key: "factor"
      value: "contrast_factor"
    }
    ruleType: "tensor"
    inputFrameworkOpName: "AdjustContrastv2"
  }
}
