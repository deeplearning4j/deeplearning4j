/* ******************************************************************************
 *
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License, Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0.
 *
 *  See the NOTICE file distributed with this work for additional
 *  information regarding copyright ownership.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

//  @author raver119@gmail.com
//  @author Yurii Shyrma (iuriish@yahoo.com)

#ifndef PAIRWISE_CU
#define PAIRWISE_CU

#include "../pairwise_transform.h"


using namespace simdOps;

////////////////////////////////////////////////////////////////////////////////
template <typename X, typename Y, typename Z, typename OpType>
SD_KERNEL static void pairwiseSimpleShaped(void const*  vx, LongType const* xShapeInfo,
                                           void const* vy, LongType const* yShapeInfo,
                                           void *vz, LongType const* zShapeInfo,
                                           void *vextraParams) {

  auto x = reinterpret_cast<X const*>(vx);
  auto y = reinterpret_cast<Y const*>(vy);
  auto z = reinterpret_cast<Z*>(vz);
  auto extraParams = reinterpret_cast<Z*>(vextraParams);

  int tid = blockIdx.x * blockDim.x + threadIdx.x;

  __shared__ LongType xEws;
  __shared__ LongType yEws;
  __shared__ LongType zEws;
  __shared__ char xOrder;
  __shared__ char yOrder;
  __shared__ char zOrder;
  __shared__ LongType len;

  if (threadIdx.x == 0) {
    xEws = shape::elementWiseStride(xShapeInfo);
    yEws = shape::elementWiseStride(yShapeInfo);
    zEws = shape::elementWiseStride(zShapeInfo);
    xOrder = shape::order(xShapeInfo);
    yOrder = shape::order(yShapeInfo);
    zOrder = shape::order(zShapeInfo);
    len = shape::length(xShapeInfo);
  }
  __syncthreads();


  if (xEws >= 1 && yEws >= 1 && zEws >= 1 && xOrder == yOrder && xOrder == zOrder) {
    for (LongType i = tid; i < len; i += gridDim.x * blockDim.x) {
      auto zOffset = i * zEws;
      auto xOffset = i * xEws;
      auto yOffset = i * yEws;
      auto xVal = x[xOffset];
      auto yVal = y[yOffset];
      auto zVal = z[zOffset];
      z[zOffset] = OpType::op(xVal,yVal, extraParams);
    }
  }
  else if (vx == vz) {
    for (LongType i = tid; i < len; i += gridDim.x * blockDim.x) {
      auto xOffset = shape::getIndexOffset(i, xShapeInfo);
      auto yOffset = shape::getIndexOffset(i, yShapeInfo);

      z[xOffset] = OpType::op(x[xOffset], y[yOffset], extraParams);
    }
  }
  else {
    for (LongType i = tid; i < len; i += gridDim.x * blockDim.x) {
      auto xOffset = shape::getIndexOffset(i, xShapeInfo);
      auto yOffset = shape::getIndexOffset(i, yShapeInfo);
      auto zOffset = shape::getIndexOffset(i, zShapeInfo);

      z[zOffset] = OpType::op(x[xOffset], y[yOffset], extraParams);
    }
  }
}

namespace functions           {
namespace pairwise_transforms {

////////////////////////////////////////////////////////////////////////////////
template<typename X, typename Y, typename Z>
template<typename OpType>
void SD_HOST PairWiseTransform<X,Y,Z>::intermediateShaped(dim3& launchDims, cudaStream_t *stream,
                                                          void const* vx, LongType const* xShapeInfo,
                                                          void const* vy, LongType const* yShapeInfo,
                                                          void *vz, LongType const* zShapeInfo,
                                                          void *vextraParams){

  pairwiseSimpleShaped<X, Y, Z, OpType><<<launchDims.x, launchDims.y, launchDims.z, *stream>>>(vx, xShapeInfo, vy, yShapeInfo, vz, zShapeInfo, vextraParams);
}

////////////////////////////////////////////////////////////////////////////////
template<typename X, typename Y, typename Z>
void SD_HOST PairWiseTransform<X,Y,Z>::executeCudaShaped(dim3& launchDims, cudaStream_t *stream, int opNum, void const* vx, LongType const* xShapeInfo, void const* vy, LongType const* yShapeInfo, void *vz, LongType const* zShapeInfo, void* vextraParams) {
  DISPATCH_BY_OPNUM_TTT(intermediateShaped, PARAMS(launchDims, stream, vx, xShapeInfo, vy, yShapeInfo, vz, zShapeInfo, vextraParams), PAIRWISE_TRANSFORM_OPS);
}


}
}

#endif // PAIRWISE_CU
