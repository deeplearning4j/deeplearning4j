/* ******************************************************************************
 *
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License, Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0.
 *
 *  See the NOTICE file distributed with this work for additional
 *  information regarding copyright ownership.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

//
// @author raver119@gmail.com
//

#ifndef SCALAR_CU
#define SCALAR_CU
#include "loops/scalar.h"
#include <cuda.h>
#include <cuda_runtime.h>
#include <system/op_boilerplate.h>
#include <helpers/TAD.h>
#include <types/types.h>

using namespace simdOps;

////////////////////////////////////////////////////////////////////////////////
template <typename X, typename Y, typename Z, typename OpType>
SD_KERNEL static void scalarSimpleShaped(void const* x, void const* y, sd::LongType const* xShapeInfo, void * params, void * z, sd::LongType const* zShapeInfo,  sd::LongType* allocationBuffer) {

  auto scalar = reinterpret_cast<Y const*>(y)[0];
  auto x2      = reinterpret_cast<X const*>(x);
  auto params2 = reinterpret_cast<Z*>(params);
  auto z2 = reinterpret_cast<Z*>(z);

  int totalThreads = gridDim.x * blockDim.x;
  int tid = blockIdx.x * blockDim.x + threadIdx.x;

  __shared__ sd::LongType length;
  if(threadIdx.x == 0) {
    length = shape::length(xShapeInfo);
  }
  __syncthreads();

  for (sd::LongType i = tid; i < length; i += totalThreads) {
    sd::LongType xCoords[SD_MAX_RANK];
    sd::LongType zCoords[SD_MAX_RANK];
    sd::LongType xOffset;
    sd::LongType zOffset;

    INDEX2COORDS(i, shape::rank(xShapeInfo), shape::shapeOf(xShapeInfo), xCoords);
    COORDS2INDEX(shape::rank(xShapeInfo), shape::stride(xShapeInfo), xCoords, xOffset);
    INDEX2COORDS(i, shape::rank(zShapeInfo), shape::shapeOf(zShapeInfo), zCoords);
    COORDS2INDEX(shape::rank(zShapeInfo), shape::stride(zShapeInfo), zCoords, zOffset);

    z2[zOffset] = OpType::op(x2[xOffset], scalar, params2);
  }
}

////////////////////////////////////////////////////////////////////////////////
template <typename X, typename Y, typename Z, typename OpType>
SD_KERNEL static void scalarAlongDimension(void const* x, sd::LongType const* xShapeInfo,
                                           void* extraParams,
                                           void* z, sd::LongType const* zShapeInfo,
                                           void const* scalars,
                                           sd::LongType* dimension,  sd::LongType dimensionLength,
                                           sd::LongType const* tadShapeInfo,  sd::LongType const* tadOffsets,
                                           sd::LongType const* tadShapeInfoZ, sd::LongType const* tadOffsetsZ) {

  auto x2 = reinterpret_cast<X const*>(x);
  auto extraParams2 = reinterpret_cast<Z*>(extraParams);
  auto z2 = reinterpret_cast<Z*>(z);
  auto scalars2 = reinterpret_cast<Y const*>(scalars);

  if (tadShapeInfoZ == nullptr) {
    tadShapeInfoZ = tadShapeInfo;
    tadOffsetsZ = tadOffsets;
  }

  auto tadLength = shape::length(tadShapeInfo);
  auto numTads = shape::length(xShapeInfo) / tadLength;

  for (int r = blockIdx.x; r < numTads; r += gridDim.x) {
    Z *oZ = z2 + tadOffsetsZ[r];
    auto oX = x2 + tadOffsets[r];

    auto s = scalars2[r];

    for (int f = threadIdx.x; f < tadLength; f += blockDim.x) {
      sd::LongType xCoords[SD_MAX_RANK];
      sd::LongType zCoords[SD_MAX_RANK];
      sd::LongType xOffset;
      sd::LongType zOffset;

      INDEX2COORDS(f, shape::rank(tadShapeInfo), shape::shapeOf(tadShapeInfo), xCoords);
      COORDS2INDEX(shape::rank(tadShapeInfo), shape::stride(tadShapeInfo), xCoords, xOffset);
      INDEX2COORDS(f, shape::rank(tadShapeInfoZ), shape::shapeOf(tadShapeInfoZ), zCoords);
      COORDS2INDEX(shape::rank(tadShapeInfoZ), shape::stride(tadShapeInfoZ), zCoords, zOffset);

      oZ[zOffset] = OpType::op(oX[xOffset], s, extraParams2);
    }
  }
}

namespace functions {
namespace scalar {

////////////////////////////////////////////////////////////////////////////////
template <typename X, typename Y, typename Z>
template <typename OpType>
void SD_HOST ScalarTransform<X, Y, Z>::intermediateShaped(dim3& launchDims, cudaStream_t* stream, void const* vx,
                                                          sd::LongType const* xShapeInfo,
                                                          sd::LongType const* hxShapeInfo, void* vz,
                                                          sd::LongType const* zShapeInfo,
                                                          sd::LongType const* hzShapeInfo, void const* vscalar,
                                                          void* vextraParams, sd::LongType* allocPointer) {

  scalarSimpleShaped<X, Y, Z, OpType><<<launchDims.x, launchDims.y, launchDims.z, *stream>>>(
      vx, vscalar, xShapeInfo, vextraParams, vz, zShapeInfo, allocPointer);
  sd::DebugHelper::checkErrorCode(stream, "scalarSimpleShapedA(...) failed");
}

////////////////////////////////////////////////////////////////////////////////
template <typename X, typename Y, typename Z>
template <typename OpType>
void SD_HOST ScalarTransform<X, Y, Z>::intermediateAlongDimension(
    dim3& launchDims, cudaStream_t* stream, void const* x, sd::LongType const* xShapeInfo, void* z,
    sd::LongType const* zShapeInfo, void const* scalars, void* extraParams, sd::LongType* dimension,
    sd::LongType dimensionLength, sd::LongType const* tadShapeInfo, sd::LongType const* tadOffsets,
    sd::LongType const* tadShapeInfoZ, sd::LongType const* tadOffsetsZ) {
  scalarAlongDimension<X, Y, Z, OpType><<<launchDims.x, launchDims.y, launchDims.z>>>(
      x, xShapeInfo, extraParams, z, zShapeInfo, scalars, dimension, dimensionLength, tadShapeInfo, tadOffsets,
      tadShapeInfoZ, tadOffsetsZ);
  sd::DebugHelper::checkErrorCode(stream, "scalarAlongDimA(...) failed");
}

////////////////////////////////////////////////////////////////////////////////
template <typename X, typename Y, typename Z>
void ScalarTransform<X, Y, Z>::executeCudaShaped(dim3& launchDims, cudaStream_t* stream, int opNum, void const* vx,
                                                 sd::LongType const* xShapeInfo, sd::LongType const* hxShapeInfo,
                                                 void* vz, sd::LongType const* zShapeInfo,
                                                 sd::LongType const* hzShapeInfo, void const* vscalar,
                                                 void* vextraParams) {
  if (sd::Environment::getInstance().isDebugAndVerbose()) printf("H14 opNum:[%i]\n", opNum);
  auto xType = sd::ArrayOptions::dataType(hxShapeInfo);
  DISPATCH_BY_OPNUM_TTT(intermediateShaped,
                        PARAMS(launchDims, stream, vx, xShapeInfo, hxShapeInfo, vz, zShapeInfo, hzShapeInfo, vscalar,
                               vextraParams, nullptr),
                        SCALAR_OPS);
}

////////////////////////////////////////////////////////////////////////////////
template <typename X, typename Y, typename Z>
void ScalarTransform<X, Y, Z>::executeCudaAlongDimension(
    dim3& launchDims, cudaStream_t* stream, int opNum, void const* vx, sd::LongType const* xShapeInfo, void* vz,
    sd::LongType const* zShapeInfo, void const* vscalars, void* vextraParams, sd::LongType* dimension,
    sd::LongType dimensionLength, sd::LongType const* tadShapeInfo, sd::LongType const* tadOffsets,
    sd::LongType const* tadShapeInfoZ, sd::LongType const* tadOffsetsZ) {
  DISPATCH_BY_OPNUM_TTT(intermediateAlongDimension,
                        PARAMS(launchDims, stream, vx, xShapeInfo, vz, zShapeInfo, vscalars, vextraParams, dimension,
                               dimensionLength, tadShapeInfo, tadOffsets, tadShapeInfoZ, tadOffsetsZ),
                        SCALAR_OPS);
}

}
}



#endif // SCALAR_CU
