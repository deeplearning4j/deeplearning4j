// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/framework/op_def.proto

package org.tensorflow.framework;

public interface OpDefOrBuilder extends
    // @@protoc_insertion_point(interface_extends:tensorflow.OpDef)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * Op names starting with an underscore are reserved for internal use.
   * Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9_]*".
   * </pre>
   *
   * <code>string opName = 1;</code>
   */
  String getName();
  /**
   * <pre>
   * Op names starting with an underscore are reserved for internal use.
   * Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9_]*".
   * </pre>
   *
   * <code>string opName = 1;</code>
   */
  com.google.protobuf.ByteString
      getNameBytes();

  /**
   * <pre>
   * Description of the input(s).
   * </pre>
   *
   * <code>repeated .tensorflow.OpDef.ArgDef input_arg = 2;</code>
   */
  java.util.List<OpDef.ArgDef>
      getInputArgList();
  /**
   * <pre>
   * Description of the input(s).
   * </pre>
   *
   * <code>repeated .tensorflow.OpDef.ArgDef input_arg = 2;</code>
   */
  OpDef.ArgDef getInputArg(int index);
  /**
   * <pre>
   * Description of the input(s).
   * </pre>
   *
   * <code>repeated .tensorflow.OpDef.ArgDef input_arg = 2;</code>
   */
  int getInputArgCount();
  /**
   * <pre>
   * Description of the input(s).
   * </pre>
   *
   * <code>repeated .tensorflow.OpDef.ArgDef input_arg = 2;</code>
   */
  java.util.List<? extends OpDef.ArgDefOrBuilder>
      getInputArgOrBuilderList();
  /**
   * <pre>
   * Description of the input(s).
   * </pre>
   *
   * <code>repeated .tensorflow.OpDef.ArgDef input_arg = 2;</code>
   */
  OpDef.ArgDefOrBuilder getInputArgOrBuilder(
          int index);

  /**
   * <pre>
   * Description of the output(s).
   * </pre>
   *
   * <code>repeated .tensorflow.OpDef.ArgDef output_arg = 3;</code>
   */
  java.util.List<OpDef.ArgDef>
      getOutputArgList();
  /**
   * <pre>
   * Description of the output(s).
   * </pre>
   *
   * <code>repeated .tensorflow.OpDef.ArgDef output_arg = 3;</code>
   */
  OpDef.ArgDef getOutputArg(int index);
  /**
   * <pre>
   * Description of the output(s).
   * </pre>
   *
   * <code>repeated .tensorflow.OpDef.ArgDef output_arg = 3;</code>
   */
  int getOutputArgCount();
  /**
   * <pre>
   * Description of the output(s).
   * </pre>
   *
   * <code>repeated .tensorflow.OpDef.ArgDef output_arg = 3;</code>
   */
  java.util.List<? extends OpDef.ArgDefOrBuilder>
      getOutputArgOrBuilderList();
  /**
   * <pre>
   * Description of the output(s).
   * </pre>
   *
   * <code>repeated .tensorflow.OpDef.ArgDef output_arg = 3;</code>
   */
  OpDef.ArgDefOrBuilder getOutputArgOrBuilder(
          int index);

  /**
   * <code>repeated .tensorflow.OpDef.AttrDef attr = 4;</code>
   */
  java.util.List<OpDef.AttrDef>
      getAttrList();
  /**
   * <code>repeated .tensorflow.OpDef.AttrDef attr = 4;</code>
   */
  OpDef.AttrDef getAttr(int index);
  /**
   * <code>repeated .tensorflow.OpDef.AttrDef attr = 4;</code>
   */
  int getAttrCount();
  /**
   * <code>repeated .tensorflow.OpDef.AttrDef attr = 4;</code>
   */
  java.util.List<? extends OpDef.AttrDefOrBuilder>
      getAttrOrBuilderList();
  /**
   * <code>repeated .tensorflow.OpDef.AttrDef attr = 4;</code>
   */
  OpDef.AttrDefOrBuilder getAttrOrBuilder(
          int index);

  /**
   * <pre>
   * Optional deprecation based on GraphDef versions.
   * </pre>
   *
   * <code>.tensorflow.OpDeprecation deprecation = 8;</code>
   */
  boolean hasDeprecation();
  /**
   * <pre>
   * Optional deprecation based on GraphDef versions.
   * </pre>
   *
   * <code>.tensorflow.OpDeprecation deprecation = 8;</code>
   */
  OpDeprecation getDeprecation();
  /**
   * <pre>
   * Optional deprecation based on GraphDef versions.
   * </pre>
   *
   * <code>.tensorflow.OpDeprecation deprecation = 8;</code>
   */
  OpDeprecationOrBuilder getDeprecationOrBuilder();

  /**
   * <pre>
   * One-line human-readable description of what the Op does.
   * </pre>
   *
   * <code>string summary = 5;</code>
   */
  String getSummary();
  /**
   * <pre>
   * One-line human-readable description of what the Op does.
   * </pre>
   *
   * <code>string summary = 5;</code>
   */
  com.google.protobuf.ByteString
      getSummaryBytes();

  /**
   * <pre>
   * Additional, longer human-readable description of what the Op does.
   * </pre>
   *
   * <code>string description = 6;</code>
   */
  String getDescription();
  /**
   * <pre>
   * Additional, longer human-readable description of what the Op does.
   * </pre>
   *
   * <code>string description = 6;</code>
   */
  com.google.protobuf.ByteString
      getDescriptionBytes();

  /**
   * <pre>
   * True if the operation is commutative ("op(a,b) == op(b,a)" for all inputs)
   * </pre>
   *
   * <code>bool is_commutative = 18;</code>
   */
  boolean getIsCommutative();

  /**
   * <pre>
   * If is_aggregate is true, then this operation accepts N &gt;= 2
   * inputs and produces 1 output all of the same opType.  Should be
   * associative and commutative, and produce output with the same
   * shape as the input.  The optimizer may replace an aggregate op
   * taking input from multiple devices with a tree of aggregate ops
   * that aggregate locally within each device (and possibly within
   * groups of nearby devices) before communicating.
   * TODO(josh11b): Implement that optimization.
   * </pre>
   *
   * <code>bool is_aggregate = 16;</code>
   */
  boolean getIsAggregate();

  /**
   * <pre>
   * By default Ops may be moved between devices.  Stateful ops should
   * either not be moved, or should only be moved if that state can also
   * be moved (e.g. via some sort of save / restore).
   * Stateful ops are guaranteed to never be optimized away by Common
   * Subexpression Elimination (CSE).
   * </pre>
   *
   * <code>bool is_stateful = 17;</code>
   */
  boolean getIsStateful();

  /**
   * <pre>
   * By default, all inputs to an Op must be initialized Tensors.  Ops
   * that may initialize tensors for the first time should set this
   * field to true, to allow the Op to take an uninitialized Tensor as
   * input.
   * </pre>
   *
   * <code>bool allows_uninitialized_input = 19;</code>
   */
  boolean getAllowsUninitializedInput();
}
